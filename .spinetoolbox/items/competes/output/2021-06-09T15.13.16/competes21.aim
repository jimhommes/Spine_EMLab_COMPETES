
MAIN MODEL Main_Competes21

  SECTION Sets_Declarations


    DECLARATION SECTION S_Declaration_Hydro

      SET:
         identifier :  HydroUnit
         subset of  :  AllGens
         index      :  hu
         definition :  {h $ (GensFuelCombo(h,'HYDRO') AND GensFueltypeCombo(h, 'CONV')) } ;

      SET:
         identifier :  PumpUnit
         subset of  :  AllGens
         index      :  pu
         definition :  {h $ (GensFuelCombo(h,'HYDRO') AND GensFueltypeCombo(h, 'PS')) }
         comment    :  "!{h $ GensFueltypeCombo(h, 'PS') }" ;

      SET:
         identifier :  DummyTimeBlocks
         subset of  :  TimeBlocks
         indices    :  b3, b4
         order by   :  -Ordblocks(b3)
         definition :  {b |ord(b) > 2}
         comment    :  "TimeBlocks in which pumping by pumped storage, hydro occurs." ;

    ENDSECTION  ;

    DECLARATION SECTION S_Declaration_Basic_Model

      SET:
         identifier   :  Contingency
         index        :  ct ;

      SET:
         identifier   :  Interfaces
         index        :  m
         order by     :  OrdInterfaces(m)
         comment      :  "Set of constrained interfaces with net transfer capabilities
                          (used in the physical representation of network)" ;

      PARAMETER:
         identifier   :  OrdInterfaces
         index domain :  m ;

      SET:
         identifier   :  AuctionInterfaces
         subset of    :  Interfaces
         index        :  am
         order by     :  m
         definition   :  {m | AuctionedInterface(m)}
         comment      :  "Subset of Interfaces representing the interfaces that take part in an explicit auction with the Netherlands" ;

      SET:
         identifier   :  Flowgates
         index        :  k
         order by     :  OrdFlowgate(k)
         comment      :  "set of constrained flowgates" ;

      PARAMETER:
         identifier   :  OrdFlowgate
         index domain :  k ;

      SET:
         identifier   :  CI
         subset of    :  (Countries, Busses)
         tags         :  (t_country, t_bus)
         index        :  l
         definition   :  {(c,i) | BussesInCountryCombo(c,i) = 1} ;

      SET:
         identifier   :  Countries
         subset of    :  SupCountries
         indices      :  c, cc, d, dd
         order by     :  suc ;

      PARAMETER:
         identifier   :  OrdCountries
         index domain :  c ;

      STRING PARAMETER:
         identifier   :  NameCountry
         index domain :  (c) ;

      SET:
         identifier   :  SupCountries
         index        :  suc
         order by     :  OrdCountries(suc) ;

      SET:
         identifier   :  CountriesA
         subset of    :  Countries
         index        :  ca
         order by     :  c
         definition   :  {c | SUM(i | BussesInCountryCombo(c,i), Arbitrage2(i) ) > 0}
         comment      :  "Countries in which arbitrage is allowed: If it contains busses where arbitrage is active for a node with positive demand" ;

      SET:
         identifier   :  AllGens
         indices      :  h, hh
         comment      :  "set of all generating units" ;

      SET:
         identifier   :  Gens
         index domain :  (f,i)
         subset of    :  AllGens
         definition   :  {h | g_unit(f,i,h) > 0}
         comment      :  "Set of generating units owned by firm f at node i in transmission network" ;

      PARAMETER:
         identifier   :  UnitInGensCombo
         index domain :  (h,f,i)
         definition   :  1 $ h in Gens(f,i) ;

      PARAMETER:
         identifier   :  FirmInCountryCombo
         index domain :  (f,c)
         definition   :  1 $ (SUM(i | (c,i) in CI, SUM(h | UnitInGensCombo(h,f,i), g_unit(f,i,h))) > 0) ;

      SET:
         identifier   :  BussesA
         subset of    :  Busses
         order by     :  i
         definition   :  {i | Arbitrage2(i) = 1}
         comment      :  "BussesA, are the set of nodes in the transmission network that are subject to arbitrage" ;

      SET:
         identifier   :  Busses
         subset of    :  SupBusses
         indices      :  i, ii
         order by     :  sb
         comment      :  "Busses are the set of nodes in the transmission network" ;

      SET:
         identifier   :  SupBusses
         index        :  sb
         order by     :  OrdBus(sb) ;

      PARAMETER:
         identifier   :  OrdBus
         index domain :  (i) ;

      SET:
         identifier   :  Firms
         subset of    :  SupFirms
         indices      :  f, ff
         order by     :  sf
         comment      :  "Set of generation firms" ;

      SET:
         identifier   :  BussesOutput
         subset of    :  Busses
         index        :  bo
         order by     :  i ;

      SET:
         identifier   :  SupFirms
         index        :  sf
         order by     :  OrdFirms(sf) ;

      PARAMETER:
         identifier   :  OrdFirms
         index domain :  sf ;

      SET:
         identifier   :  Shareholding
         subset of    :  SupFirms
         index        :  sh
         order by     :  sf ;

      PARAMETER:
         identifier   :  AuctionedInterface
         index domain :  (m) ;

    ENDSECTION  ;

    DECLARATION SECTION S_Declaration_Marg_Costs

      SET:
         identifier   :  Fuels
         subset of    :  SupFuels
         index        :  fu
         order by     :  suf ;

      SET:
         identifier   :  SupFuels
         index        :  suf
         order by     :  OrdFuels(suf) ;

      SET:
         identifier   :  FuelTypes
         subset of    :  SupFuelTypes
         index        :  ft
         order by     :  sft ;

      SET:
         identifier   :  SupFuelTypes
         index        :  sft
         order by     :  OrdFuelTypes(sft) ;

      SET:
         identifier   :  OldFuels
         subset of    :  OldSupFuels
         index        :  ofu ;

      SET:
         identifier   :  OldSupFuels
         index        :  osuf ;

      SET:
         identifier   :  OldFuelTypes
         subset of    :  OldSupFuelTypes
         index        :  oft ;

      SET:
         identifier   :  OldSupFuelTypes
         index        :  osft ;

      PARAMETER:
         identifier   :  OrdFuels
         index domain :  (suf) ;

      PARAMETER:
         identifier   :  OrdFuelTypes
         index domain :  (sft) ;

    ENDSECTION  ;

    DECLARATION SECTION Time_Dependency

      SET:
         identifier   :  TimeBlocks
         indices      :  b, b2
         order by     :  OrdBlocks(b) ;

      PARAMETER:
         identifier   :  OrdBlocks
         index domain :  (b) ;

      PARAMETER:
         identifier   :  Hulp_OrdBlocks
         index domain :  (u,b) ;

      SET:
         identifier   :  Seasons
         index        :  u
         order by     :  OrdSeason(u) ;

      PARAMETER:
         identifier   :  OrdSeason
         index domain :  u ;

      SET:
         identifier   :  Periods
         subset of    :  (Seasons, TimeBlocks)
         tags         :  (t_s, t_t)
         index        :  p
         parameter    :  CurrentPeriod
         order by     :  OrdPeriods(p) ;

      PARAMETER:
         identifier   :  OrdPeriods
         index domain :  (u,b)
         definition   :  10*OrdSeason(u) + OrdBlocks(b) ;

      SET:
         identifier   :  SelectionOfPeriods
         subset of    :  Periods ;

      PARAMETER:
         identifier   :  SelectedPeriods
         index domain :  p
         definition   :  IF p in SelectionOfPeriods THEN
                         1
                         ELSE
                         0
                         ENDIF  ;

    ENDSECTION  ;

  ENDSECTION Sets_Declarations ;

  SECTION Parameter_Declarations


    DECLARATION SECTION P_Declaration_Hydro

      PARAMETER:
         identifier   :  GPROD_max
         index domain :  (f,i,h,p) ;

      PARAMETER:
         identifier   :  GA_max
         index domain :  (f,i,h,p) ;

      PARAMETER:
         identifier   :  GA_min
         index domain :  (f,i,h,p) ;

      PARAMETER:
         identifier   :  CapacityFactor
         index domain :  (c,h) ;

      PARAMETER:
         identifier   :  H_max
         index domain :  (h,u)
         definition   :  2 * CapacityFactor(CountryU(h),h)* SUM[b, Time(u,b)] ;

      PARAMETER:
         identifier   :  H_maxp
         index domain :  (pu,u)
         definition   :  H_max(pu,u)/(EffPH*DerPH)
         comment      :  "Numbers of hours in which pumped storage is pumping" ;

      PARAMETER:
         identifier   :  EffPH
         definition   :  0.75
         comment      :  "Efficiency of pumped hydro (MWh energy out/ MWh energy in)" ;

      PARAMETER:
         identifier   :  DerPH
         definition   :  0.75 ;

    ENDSECTION  ;

    DECLARATION SECTION P_Declaration_Basic_Model

      PARAMETER:
         identifier   :  AdditionalCap
         index domain :  (h)
         comment      :  "MW in order to adapt capacity by hand" ;

      PARAMETER:
         identifier   :  IsModelPeriod
         index domain :  (p) ;

      STRING PARAMETER:
         identifier   :  Operation
         index domain :  (h)
         comment      :  "Indicates whether a plant is in operation, planned or retired et cetera. Equivalent to \"STATUS\" in WEPP dbase" ;

      PARAMETER:
         identifier   :  PerfectComp
         definition   :  IF Choose('Competitive') = 1 THEN
                         1
                         ELSE
                         0
                         ENDIF
         comment      :  "Used for the interface" ;

      PARAMETER:
         identifier   :  ChangeInitialDemand
         range        :  binary ;

      PARAMETER:
         identifier   :  availability
         index domain :  (fu,ft,i,p) ;

      PARAMETER:
         identifier   :  EE
         index domain :  (i,p)
         range        :  (-inf, inf)
         comment      :  "Positive is export; Negative is import from external countries to node i" ;

      PARAMETER:
         identifier   :  AD
         index domain :  (i,p)
         comment      :  "AD(i,p) is additional demand at a certain node. This is used for sensitivity analysis to the initial demand Qzero.
                          By simulating this via AD(i,p), the slope of the demand curve will not be altered." ;

      PARAMETER:
         identifier   :  ETAX
         index domain :  (c, cc)
         comment      :  "Export tax for sales from country c to country cc. This tax rate is exogenous
                          to the model; more general models could be formulated where tax rates are a variable
                          set to recover a prespecified fixed transmission cost." ;

      PARAMETER:
         identifier   :  WC
         index domain :  (f,i)
         comment      :  "Slope of conjectured transmission response function for firm \"f\" at bus/node \"i\"" ;

      PARAMETER:
         identifier   :  SFC
         index domain :  (f,i)
         range        :  nonnegative
         comment      :  "Inverse slope of the CSF (conjectured supply function)" ;

      PARAMETER:
         identifier   :  Cournot
         index domain :  (f,i)
         range        :  binary
         comment      :  "Firm f has a cournot strategy, yes: 1, no: 0" ;

      PARAMETER:
         identifier   :  g_max
         index domain :  (f,i,h,p)
         definition   :  (g_unit(f,i,h)+ (AdditionalCap(h) $ g_unit(f,i,h)) )* availability(FuelU(h), FueltypeU(h),i,p)
         comment      :  "Capacity of generator fih, taking account of the availability" ;

      PARAMETER:
         identifier   :  g_unit
         index domain :  (f,i,h)
         comment      :  "Capacity of unit h for firm f (taken account of the stocks)" ;

      PARAMETER:
         identifier   :  PTDF
         index domain :  (i,k,ct,p)
         comment      :  "Power transmission distribution factor describing the MW increase in flow through
                          flowgate k resulting from a 1 MW increase in power transferred from hub to node i" ;

      PARAMETER:
         identifier   :  T
         index domain :  (k,ct)
         comment      :  "Upper limit for flow through flowgate k for contingency ct" ;

      PARAMETER:
         identifier   :  DEM_M_pc
         index domain :  (i,p) ;

      PARAMETER:
         identifier   :  e
         index domain :  i
         comment      :  "Demand elasticity" ;

      PARAMETER:
         identifier   :  DEM_M
         index domain :  (i,p) | Qzero(i,p) <> 0
         definition   :  IF PerfectComp = 1 THEN
                                 DEM_M_pc(i,p) - DEM_S(i,p)*EE(i,p)
                         ELSE Pzero(i,p) - DEM_S(i,p)*(Qzero(i,p) + EE(i,p) + AD(i,p) - Load_Decrease(i,p))
                         ENDIF
         comment      :  "Intercept of the inverse demand function Pi" ;

      PARAMETER:
         identifier   :  DEM_M_Dummy
         index domain :  (i,p)
         comment      :  "This is used to calculate the correct value of welfare/value/costs in the competitive case.
                          This calculation should namely be based on the 'correct' demand-curve." ;

      PARAMETER:
         identifier   :  DEM_S_Dummy
         index domain :  (i,p)
         comment      :  "This is used to calculate the correct value of welfare/value/costs in the competitive case. This calculation
                          should namely be based on the 'correct' demand-curve." ;

      PARAMETER:
         identifier   :  DEM_S
         index domain :  (i,p) | Qzero(i,p) <> 0
         definition   :  IF PerfectComp = 1 THEN
                         -DEM_M_pc(i,p)/Qzero(i,p)
                         ELSE (1/e(i))*Pzero(i,p)/Qzero(i,p)
                         ENDIF
         comment      :  "Slope of the inverse demand function Pi" ;

      PARAMETER:
         identifier   :  WCT
         index domain :  (f,m,p)
         comment      :  "Slope for firm f's conjectured transmission capability
                          price response function for interface m" ;

      PARAMETER:
         identifier   :  PTC
         index domain :  (m,p)
         comment      :  "Net power transfer capability for interface constraint m [MW]
                          (for intercountry constraints)" ;

      PARAMETER:
         identifier   :  PTCU
         index domain :  (c,cc,m)
         comment      :  "MW of transfer capability in interface m
                          consumed by a 1 MW transfer from country c to country cc
                          Will usually be 0, 1 or 01" ;

      PARAMETER:
         identifier   :  ATCU
         index domain :  (c,cc,am)
         comment      :  "Values 0 or 1. Value 1 indicates that the auction on interface am will be used when power is transferred from country c to cc by either a firm or an arbitrageur" ;

      PARAMETER:
         identifier   :  TCA
         index domain :  am
         comment      :  "[MW] Capacity of the auction available for arbitrageurs" ;

      PARAMETER:
         identifier   :  TC
         index domain :  (f,am)
         comment      :  "[MW] Transmission capacity available for firms on the auction" ;

    ENDSECTION  ;

    DECLARATION SECTION P_Declaration_Marg_Costs

      PARAMETER:
         identifier   :  AdditionalMC
         index domain :  h
         comment      :  "[EUR/MWh] In order to increase/decrease MC of a unit \"by hand\"" ;

      PARAMETER:
         identifier   :  Cap
         index domain :  (h)
         definition   :  g_unit(FirmU(h),BusU(h),h) ;

      PARAMETER:
         identifier   :  GensFuelCombo
         index domain :  (h,fu)
         definition   :  IF FuelU(h) = fu THEN
                         1
                         ELSE
                         0
                         ENDIF  ;

      PARAMETER:
         identifier   :  GensFuelTypeCombo
         index domain :  (h,ft)
         definition   :  IF FueltypeU(h) = ft THEN
                         1
                         ELSE
                         0
                         ENDIF  ;

      PARAMETER:
         identifier   :  MC
         index domain :  (h)
         definition   :  sum(c$GensCountryCombo(h,c),Fuelprice(FuelU(h), FueltypeU(h),c)/$ Efficiency(FuelU(h), FueltypeU(h),c)*3.6
                         + Maintenance(FuelU(h), FueltypeU(h))
                         + AdditionalMC(h)
                         + CO2_Costs(h,c))
         comment      :  "[€/MWh] Marginal costs consists of fuel and variable maintenance: First  3.6/0.92294, this is removed now, why 0.92294?" ;

      PARAMETER:
         identifier   :  CO2_Emissions
         index domain :  (h,c)
         definition   :  FuelEmission(FuelU(h), FueltypeU(h))/$ Efficiency(FuelU(h), FueltypeU(h),c)*3.6
         comment      :  "Emissions in kg/MWh. First I had 3.6/0.92294, but I do not know why I should use 0.92294?" ;

      PARAMETER:
         identifier   :  CO2_Costs
         index domain :  (h,c)
         definition   :  (CO2_Emissions(h,c)/1000) * CO2_Price
         comment      :  "[€/MWh] CO2_Price in €/ton CO2, CO2_Emissions in kg/MWh" ;

      PARAMETER:
         identifier   :  CO2_Price
         default      :  0
         comment      :  "€/ton CO2" ;

      ELEMENT PARAMETER:
         identifier   :  CountryU
         index domain :  (h)
         range        :  Countries
         default      :  '' ;

      PARAMETER:
         identifier   :  GensCountryCombo
         index domain :  (h,c) ;

      ELEMENT PARAMETER:
         identifier   :  FuelU
         index domain :  (h)
         range        :  Fuels
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  FueltypeU
         index domain :  (h)
         range        :  FuelTypes
         default      :  '-' ;

      PARAMETER:
         identifier   :  Efficiency
         index domain :  (fu,ft,c) ;

      PARAMETER:
         identifier   :  Fuelprice
         index domain :  (fu,ft,c)
         comment      :  "[EUR2000/GJ]" ;

      PARAMETER:
         identifier   :  FuelEmission
         index domain :  (fu,ft)
         comment      :  "[kg/GJ]" ;

      ELEMENT PARAMETER:
         identifier   :  FirmU
         index domain :  (h)
         range        :  Firms
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  BusU
         index domain :  (h)
         range        :  SupBusses
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  TestBusU
         index domain :  (h)
         range        :  Busses
         default      :  '' ;

      PARAMETER:
         identifier   :  FC
         index domain :  (fu,ft,ofu,oft)
         text         :  "Combining old and new fuels" ;

      PARAMETER:
         identifier   :  FTC
         index domain :  (ft,oft)
         text         :  "Combining old and new fueltypes" ;

      ELEMENT PARAMETER:
         identifier   :  FUV
         index domain :  (ofu,oft)
         text         :  "New fuel value converted from old fuel"
         range        :  Fuels ;

      ELEMENT PARAMETER:
         identifier   :  FTV
         index domain :  (ofu,oft)
         text         :  "New fueltype value converted from old fueltype"
         range        :  FuelTypes ;

    ENDSECTION  ;

    DECLARATION SECTION Initial_values

      PARAMETER:
         identifier   :  Time
         index domain :  p
         comment      :  "in hours" ;

      PARAMETER:
         identifier   :  UnitX
         index domain :  (i) ;

      PARAMETER:
         identifier   :  UnitY
         index domain :  (i) ;

      PARAMETER:
         identifier   :  Flow
         index domain :  (i,ii,p)
         definition   :  y(ii,p) ;

      PARAMETER:
         identifier   :  Qzero
         index domain :  (i,p)
         range        :  nonnegative
         comment      :  "This is the inititial demand at bus (node) i" ;

      PARAMETER:
         identifier   :  Pzero
         index domain :  (i,p) ;

    ENDSECTION  ;

    DECLARATION SECTION Multipliers

      PARAMETER:
         identifier   :  MultiplierInterface
         initial data :  1
         comment      :  "Path-based transmission" ;

      PARAMETER:
         identifier   :  MultiplierPhysicalFlowgate
         initial data :  1
         comment      :  "Physical network - linearized DC load flow" ;

    ENDSECTION  ;

    DECLARATION SECTION Internal_Sourcing

      PARAMETER:
         identifier   :  Criteria_1
         index domain :  (h,b)
         definition   :  (SUM[b2 | ord(b2) >= ord(b), Criteria_InternalSource(h,b2) ] ) ;

      PARAMETER:
         identifier   :  Value_1
         index domain :  (h,b)
         definition   :  MAX[b2 | ord(b2) >= ord(b), Criteria_InternalSource(h,b2) ] ;

      PARAMETER:
         identifier   :  Check_internal
         index domain :  p
         definition   :  1 $ SUM(f, Company_InternalSource(f,p)) - SUM(i, Load_Decrease(i,p)) < 0.01 ;

      PARAMETER:
         identifier   :  Internal_source
         index domain :  (h,p) ;

      PARAMETER:
         identifier   :  CompanySources
         index domain :  (f,b) ;

      PARAMETER:
         identifier   :  AtMaxGeneration
         index domain :  (h,p)
         definition   :  IF ABS( SUM[(f,i) $ UnitInGensCombo(h,f,i), generation0(f,i,h,p)] - SUM[(f,i) $ UnitInGensCombo(h,f,i), GA_max(f,i,h,p)] ) < 0.01 THEN
                         1
                         ELSE
                         0
                         ENDIF  ;

      PARAMETER:
         identifier   :  Criteria_InternalSource
         index domain :  (h,b)
         definition   :  (1-LeveringAanMarkt(h,b))* CompanySources(FirmU(h), b) * MIN[u , AtMaxGeneration(h,u,b)] 
         comment      :  "This unit in this block will only be available for Internal Sourcing when:
                          (1) unit produces at maximum load in this timeblock for all seasons
                          (2) company decides to internal deliver production dispatched during this timeblock 'b'." ;

      PARAMETER:
         identifier   :  Percentage_decrease
         index domain :  (c,p)
         definition   :  SUM[ (f,i,h) $ BussesInCountryCombo(c,i), GA_max(f,i,h,p) * Internal_source(h,p) ]
                         /$ SUM[ i $ BussesInCountryCombo(c,i), Qzero(i,p)] ;

      PARAMETER:
         identifier   :  Company_InternalSource
         index domain :  (f,p)
         definition   :  SUM[(i,h), GA_max(f,i,h,p) * Internal_source(h,p)]
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  Load_Decrease
         index domain :  (i,p)
         definition   :  SUM[c $ BussesInCountryCombo(c,i), Percentage_decrease(c,p) * Qzero(i,p)] ;

      PARAMETER:
         identifier   :  Generation0
         index domain :  (f,i,h,p) ;

      PARAMETER:
         identifier   :  CheckExports
         index domain :  (f,c,cc,b,u) ;

      PARAMETER:
         identifier   :  LeveringAanMarkt
         index domain :  (h,b)
         comment      :  "MB: Het kiezen van welke centrales, ondanks selectie voor interne doorlevering, toch aan de markt zullen leveren kan geautomatiseerd
                          worden. Je moet dan kijken naar de totale doorlevering op basis van de automatische selectie.
                          Als deze totale doorlevering hoger is dan de minimale verkopen aan de Nederlandse markt, wil je dat de centrales
                          met de hoogste MC niet voor interne doorlevering geselecteerd worden. Oftwel: LeveringAanMarkt wordt positief!
                          
                          Fractie van de capaciteit van de centrale dat nog WEL aan de markt wordt geleverd (ondanks dat deze op basis van
                          de criteria geselecteerd zou worden om intern door te leveren voor 100%).
                          
                          Op 1 als deze wel aan de markt gaat leveren
                          Op 1 als deze alsnog niet voor interne levering mag worden gebruikt!" ;

      PARAMETER:
         identifier   :  MinimumSales
         index domain :  (f,c,b)
         definition   :  MIN(u, TotalSalesInCountry(f,c,u,b)) ;

    ENDSECTION  ;

    SECTION NMa_procedures


      PROCEDURE
        identifier :  Fill_Generation0
        body       :  
          Generation0(f,i,h,p) := g(f,i,h,p);

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Fill_Source
        body       :  
          Internal_source(h,u,b) := 0;
          Internal_source(h,u,b) $  ( Criteria_1(h,b) > 0 )  :=  Value_1(h,b)  ;

      ENDPROCEDURE  ;

    ENDSECTION NMa_procedures ;

  ENDSECTION Parameter_Declarations ;

  SECTION LP_formulation


    SECTION LP_Procedures


      PROCEDURE
        identifier :  CalcRGC
        body       :  
          FOR (i,p) DO
           RGC2(i,p) := max((f,h) $ (g2(f,i,h,p) > 0), MC(h));
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  SetPrices
        body       :  
          FOR (i,p) DO
           Pzero(i,p)     := pStar2(i,p);
           y(i,p)         := y2(i,p);
           FOR f DO
            s(f,i,p)      := s2(f,i,p);
            FOR h $ UnitInGensCombo(h,f,i) DO
             g(f,i,h,p)   := g2(f,i,h,p)
            ENDFOR
           ENDFOR
          ENDFOR;
          FOR (f,c,cc,p) $ FirmInCountryCombo(f,c) DO
           ps(f,c,cc,p)   := ps2(f,c,cc,p)
          ENDFOR

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  LP_MainExecution
        comment    :  "Periods for which the model must run can be selected via input pages. The model solves for each consecutive period selected."
        body       :  
          ShowProgressWindow(1);
          
          FOR p $ SelectedPeriods(p)  DO
              empty IsModelPeriod;
              IsModelPeriod(p) := 1;
              solve COMPETES_LP in merge mode;
              break when COMPETES_LP.ProgramStatus = 'Infeasible';
              PageRefreshAll;
          ENDFOR;
          IsModelPeriod(p) := 1;
          
          !Calculation of equilibrium prices  (max MC), equal among contries which still have no congestion.
          FOR (i,p) DO
           RGC2(i,p) := max((f,h) $ (g2(f,i,h,p) > 0), MC(h));
          ENDFOR;
          FOR (i,p) DO
           IF (max(ii $ ((PTCU2(i,ii) = 1) AND (RGC2(i,p) - RGC2(ii,p) < 0) AND (NOT congest3(i,ii,p) = 1)), RGC2(ii,p)) > RGC2(i,p))
           THEN pStar2(i,p) := max(ii $ ((PTCU2(i,ii) = 1) AND (RGC2(i,p) - RGC2(ii,p) < 0) AND (NOT congest3(i,ii,p) = 1)), RGC2(ii,p))
           ELSE pStar2(i,p) := RGC2(i,p)
           ENDIF;
          ENDFOR;
          
          WHILE (sum((i,p), ABS(RGC2(i,p) - pStar2(i,p))) > 0.01) DO
           FOR (i,p) DO
            RGC2(i,p) := pStar2(i,p);
           ENDFOR;
           FOR (i,p) DO
            IF (max(ii $ ((PTCU2(i,ii) = 1) AND (RGC2(i,p) - RGC2(ii,p) < 0) AND (NOT congest3(i,ii,p) = 1)), RGC2(ii,p)) > RGC2(i,p))
            THEN pStar2(i,p) := max(ii $ ((PTCU2(i,ii) = 1) AND (RGC2(i,p) - RGC2(ii,p) < 0) AND (NOT congest3(i,ii,p) = 1)), RGC2(ii,p))
            ELSE pStar2(i,p) := RGC2(i,p)
            ENDIF;
           ENDFOR
          ENDWHILE;

      ENDPROCEDURE  ;

    ENDSECTION LP_Procedures ;

    DECLARATION SECTION LP_model

      CONSTRAINT:
         identifier   :  thetaS2
         index domain :  (f,c,p) | (IsModelPeriod(p) AND FirmsTradeCountry(f,c))
         definition   :  SUM[ i | BussesInCountryCombo(c,i), s2(f,i,p) ] - SUM[cc | FirmInCountryCombo(f,cc), ps2(f,cc,c,p) ] = 0 ;

      CONSTRAINT:
         identifier   :  thetaG2
         index domain :  (f,c,p) | (FirmInCountryCombo(f,c)) and (IsModelPeriod(p))
         definition   :  -1 * ( SUM[ i | BussesInCountryCombo(c,i), SUM[ h | UnitInGensCombo(h,f,i), g2(f,i,h,p) ] ] ) +
                         SUM[ cc | FirmInCountryCombo(f,c), ps2(f,c,cc,p) ] = 0 ;

      CONSTRAINT:
         identifier   :  mu_min2
         index domain :  (f,i,h,p) | (UnitInGensCombo(h,f,i)) and (IsModelPeriod(p))
         definition   :  g2(f,i,h,p) - (1-Internal_source(h,p))*GA_min(f,i,h,p) >= 0 ;

      CONSTRAINT:
         identifier   :  mu_plus2
         index domain :  (f,i,h,p) | (UnitInGensCombo(h,f,i)) and (IsModelPeriod(p))
         definition   :  g2(f,i,h,p) - (1-Internal_source(h,p))*GA_max(f,i,h,p) <= 0 ;

      CONSTRAINT:
         identifier   :  FixedDemand
         index domain :  (i,p) | IsModelPeriod(p)
         definition   :  Qzero(i,p) + EE(i,p) - sum(f,s2(f,i,p)) = 0 ;

      CONSTRAINT:
         identifier   :  wtStar2
         index domain :  (m,p) | IsModelPeriod(p)
         definition   :  SUM[ (c,cc), PTCU(c,cc,m) * SUM( f | FirmInCountryCombo(f,c) , ps2(f,c,cc,p) ) ] - MultiplierInterface*PTC(m,p) <= 0 ;

      VARIABLE:
         identifier   :  y2
         index domain :  (i,p) | IsModelPeriod(p)
         range        :  real
         definition   :  SUM(f, s2(f,i,p) - SUM(h | UnitInGensCombo(h,f,i), g2(f,i,h,p) ))
         comment      :  "MW of transmission services provided by TSO from hub node to node \"i\"" ;

      VARIABLE:
         identifier   :  g2
         index domain :  (f,i,h,p)| (UnitInGensCombo(h,f,i)) and (IsModelPeriod(p))
         comment      :  "-MC(h) + (wStar(i,p) + WC(f,i)*( s(f,i,p) - SUM( hh | UnitInGensCombo(hh,f,i), g(f,i,hh,p) ) ) ) -
                          (mu_min(f,i,h,p)+mu_plus(f,i,h,p)) + SUM[c | BussesInCountryCombo(c,i), thetaG(f,c,p) ] = 0" ;

      VARIABLE:
         identifier   :  s2
         index domain :  (f,i,p) | (FirmsTradeNode(f,i) AND IsModelPeriod(p) AND Qzero(i,p) <> 0)
         range        :  nonnegative
         comment      :  "(DEM_M(i,p)+DEM_S(i,p)*(SUM(ff, s(ff,i,p)) + (a(i,p) $ arbitrage2(i))) + (1-PerfectComp)*Cournot(f,i)*DEM_S(i,p)*s(f,i,p)/(1-DEM_S(i,p)*SFC(f,i))
                           - (wStar(i,p) + WC(f,i)*(s(f,i,p)-SUM(hh|UnitInGensCombo(hh,f,i), g(f,i,hh,p)))) - SUM[c | BussesInCountryCombo(c,i), thetaS(f,c,p)]) <= 0" ;

      VARIABLE:
         identifier   :  ps2
         index domain :  (f,c,cc,p) | (FirmInCountryCombo(f,c)) and ( IsModelPeriod(p) )
         range        :  nonnegative
         comment      :  "-1*( ETAX(c,cc) + SUM[ m, ( wtStar(m,p) + WCT(f,m,p) *
                          SUM[ (d,dd) | FirmInCountryCombo(f,d), PTCU(d,dd,m) * ps(f,d,dd,p) ] )  * PTCU(c,cc,m) ] ) +
                          thetaS(f,cc,p) - thetaG(f,c,p) - SUM[am, ATCU(c,cc,am)*gamm(f,am,p)] <= 0" ;

    ENDSECTION  ;

    DECLARATION SECTION LP_Parameters

      PARAMETER:
         identifier   :  congest
         index domain :  (m,p)
         definition   :  SUM[ (c,cc), PTCU(c,cc,m) * SUM( f | FirmInCountryCombo(f,c) , ps2(f,c,cc,p) ) ] - MultiplierInterface*PTC(m,p) = 0 ;

      PARAMETER:
         identifier   :  congest2
         index domain :  (c,cc,p)
         definition   :  sum(m,congest(m,p) * PTCU(c,cc,m)) /$ sum(m,congest(m,p) * PTCU(c,cc,m)) ;

      PARAMETER:
         identifier   :  congest3
         index domain :  (i,ii,p)
         definition   :  sum((c,cc) $ (((c,i) in CI) and ((cc,ii) in CI)), congest2(c,cc,p)) ;

      PARAMETER:
         identifier   :  PTCU2
         index domain :  (i,ii)
         definition   :  sum((c,cc,m) $ (((c,i) in CI) and ((cc,ii) in CI)), PTCU(c,cc,m))
                         /$ sum((c,cc,m) $ (((c,i) in CI) and ((cc,ii) in CI)), PTCU(c,cc,m)) ;

      PARAMETER:
         identifier   :  RGC2
         index domain :  (i,p) ;

      PARAMETER:
         identifier   :  pStar2
         index domain :  (i,p)
         comment      :  "max((f,h,ii) $ ((g2(f,i,h,p) > 0) and NOT congest3(i,ii,p) = 1), MC(h))
                          
                          DEM_M(i,p) + DEM_S(i,p) * ( SUM(f, s(f,i,p)) + (a(i,p) $ arbitrage2(i)) )
                          EUR/MWh price of energy at node i" ;

    ENDSECTION  ;

    DECLARATION SECTION LP_Declaration

      VARIABLE:
         identifier  :  ProfitTot
         definition  :   - sum((f,i,h,p),g2(f,i,h,p) * MC(h))
         comment     :  "-sum((i,p),pStar2(i,p) )
                         sum((f,i,p),pStar2(i,p) * s2(f,i,p) ) - sum((f,i,h,p),g2(f,i,h,p) * MC(h))" ;

      SET:
         identifier  :  SelectedEquations_LP
         subset of   :  AllConstraints
         definition  :  data { y2, wtStar2, mu_plus2, mu_min2, thetaS2, thetaG2, FixedDemand } ;

      SET:
         identifier  :  SelectedVariables_LP
         subset of   :  AllVariables
         definition  :  data { y2, g2, s2, ps2 } ;

      MATHEMATICAL PROGRAM:
         identifier  :  COMPETES_LP
         objective   :  ProfitTot
         direction   :  maximize
         constraints :  SelectedEquations_LP
         variables   :  SelectedVariables_LP
         type        :  lp ;

    ENDSECTION  ;

  ENDSECTION LP_formulation ;

  SECTION KKT_Conditions


    DECLARATION SECTION TSO_model

      VARIABLE:
         identifier   :  y
         index domain :  (i,p) | IsModelPeriod(p)
         range        :  real
         definition   :  (a(i,p) $ arbitrage2(i)) + SUM(f, s(f,i,p) - SUM(h | UnitInGensCombo(h,f,i), g(f,i,h,p) ))
         comment      :  "MW of transmission services provided by TSO from hub node to node \"i\"" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  wtStar
         index domain :  (m,p) | IsModelPeriod(p)
         range        :  nonnegative
         complement   :  z(m,p) - MultiplierInterface*PTC(m,p) <= 0
         comment      :  "EUR/MWh price of transfer capability for interface m. This is the price
                          associated with use of transfer capabilities represented as a transportation model." ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  lambda_plus
         index domain :  (k,ct,p)| IsModelPeriod(p)
         range        :  nonnegative
         complement   :  SUM(i, PTDF(i,k,ct,p)*y(i,p)) - MultiplierPhysicalFlowgate * T(k,ct) <= 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  lambda_min
         index domain :  (k,ct,p)| IsModelPeriod(p)
         range        :  nonnegative
         complement   :  SUM(i, -PTDF(i,k,ct,p)*y(i,p)) - MultiplierPhysicalFlowgate * T(k,ct) <= 0 ;

    ENDSECTION  ;

    DECLARATION SECTION Generator_model

      PARAMETER:
         identifier   :  temp2
         index domain :  (f,c,cc) | (FirmInCountryCombo(f,c)) and (FirmsTradeCountry(f,cc))
         definition   :  1 ;

      PARAMETER:
         identifier   :  gtot
         index domain :  (i,p)
         definition   :  sum((f,h),g(f,i,h,p)) ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  thetaS
         index domain :  (f,c,p) | (IsModelPeriod(p) AND FirmsTradeCountry(f,c))
         range        :  real
         complement   :  SUM[ i | BussesInCountryCombo(c,i), s(f,i,p) ] - SUM[cc | FirmInCountryCombo(f,cc), ps(f,cc,c,p) ] = 0
         comment      :  "SUM[i | (c,i) in CI, s(f,i,p) ] - SUM[cc | FirmInCountryCombo(f,cc), ps(f,cc,c) ] = 0" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  thetaG
         index domain :  (f,c,p) | (FirmInCountryCombo(f,c)) and (IsModelPeriod(p))
         range        :  real
         complement   :  -1 * ( SUM[ i | BussesInCountryCombo(c,i), SUM[ h | UnitInGensCombo(h,f,i), g(f,i,h,p) ] ] ) +
                         SUM[ cc | FirmInCountryCombo(f,c), ps(f,c,cc,p) ] = 0
         comment      :  "-1 * ( SUM(i | (c,i) in CI, SUM(h | UnitInGensCombo(h,f,i), g(f,i,h,p) ) ) ) + SUM(cc | FirmInCountryCombo(f,cc), ps(f,c,cc,p) ) = 0
                          
                          h in Gens(f,l.t_bus)
                          
                          !-1 * ( SUM[ l | l.t_country = c, SUM[ h | UnitInGensCombo(h,f,l.t_bus), g(f,l.t_bus,h,p) ] ] ) +
                          !SUM[ cc | FirmInCountryCombo(f,c), ps(f,c,cc,p) ] = 0" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  mu_min
         index domain :  (f,i,h,p) | (UnitInGensCombo(h,f,i)) and (IsModelPeriod(p))
         range        :  nonpositive
         complement   :  g(f,i,h,p) - (1-Internal_source(h,p))*GA_min(f,i,h,p) >= 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  gamm
         index domain :  (f,am,p) | IsModelPeriod(p)
         range        :  nonnegative
         complement   :  SUM[(c,cc), ATCU(c,cc,am) * ps(f,c,cc,p)] - TC(f,am) <= 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  mu_plus
         index domain :  (f,i,h,p) | (UnitInGensCombo(h,f,i)) and (IsModelPeriod(p))
         range        :  nonnegative
         complement   :  g(f,i,h,p) - (1-Internal_source(h,p))*GA_max(f,i,h,p) <= 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  g
         index domain :  (f,i,h,p)| (UnitInGensCombo(h,f,i)) and (IsModelPeriod(p))
         complement   :  -MC(h) + (wStar(i,p) + WC(f,i)*( s(f,i,p) - SUM( hh | UnitInGensCombo(hh,f,i), g(f,i,hh,p) ) ) ) -
                         (mu_min(f,i,h,p)+mu_plus(f,i,h,p)) + SUM[c | BussesInCountryCombo(c,i), thetaG(f,c,p) ] = 0
         comment      :  "Generation by unit h owned by firm f at node i (MWe)
                          
                          -MC(f,i,h) + (wStar(i,p) + WC(f,i)*( s(f,i,p) - SUM( hh | UnitInGensCombo(hh,f,i), g(f,i,hh) ) ) ) -
                          (mu_min(f,i,h,p)+mu_plus(f,i,h,p)) + SUM(c | (c,i) in CI, thetaG(f,c,p) ) <= 0" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  s
         index domain :  (f,i,p) | (FirmsTradeNode(f,i) AND IsModelPeriod(p) AND Qzero(i,p) <> 0)
         range        :  nonnegative
         complement   :  (DEM_M(i,p)+DEM_S(i,p)*(SUM(ff, s(ff,i,p)) + (a(i,p) $ arbitrage2(i))) + (1-PerfectComp)*Cournot(f,i)*DEM_S(i,p)*s(f,i,p)/(1-DEM_S(i,p)*SFC(f,i))
                          - (wStar(i,p) + WC(f,i)*(s(f,i,p)-SUM(hh|UnitInGensCombo(hh,f,i), g(f,i,hh,p)))) - SUM[c | BussesInCountryCombo(c,i), thetaS(f,c,p)]) <= 0
         comment      :  "DEM_M(i,p)+DEM_S(i,p)*(SUM(ff, s(ff,i)) + a(i,p)) + (1-PerfectComp)*Cournot(f,i)*DEM_S(i,p)*s(f,i,p)/(1-DEM_S(i,p)*SFC(f,i))
                           - (wStar(i,p) + WC(f,i)*(s(f,i,p)-SUM(hh | UnitInGensCombo(hh,f,i), g(f,i,hh)))) - SUM(c | (c,i) in CI, thetaS(f,c,p)) <= 0" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  ps
         index domain :  (f,c,cc,p) | (FirmInCountryCombo(f,c)) and ( IsModelPeriod(p) ) and (FirmsTradeCountry(f,cc))
         range        :  nonnegative
         complement   :  -1*( ETAX(c,cc) + SUM[ m, ( wtStar(m,p) + WCT(f,m,p) *
                         SUM[ (d,dd) | FirmInCountryCombo(f,d), PTCU(d,dd,m) * ps(f,d,dd,p) ] )  * PTCU(c,cc,m) ] ) +
                         thetaS(f,cc,p) - thetaG(f,c,p) - SUM[am, ATCU(c,cc,am)*gamm(f,am,p)] <= 0
         comment      :  "MW power sales by firm f in country cc assigned to generation in country c" ;

    ENDSECTION  ;

    DECLARATION SECTION Market_Clearing_Conditions

      PARAMETER:
         identifier   :  wtot
         index domain :  (i,p)
         definition   :  SUM((k,ct), PTDF(i,k,ct,p)*(lambda_plus(k,ct,p)-lambda_min(k,ct,p)) ) ;

      PARAMETER:
         identifier   :  Stot
         index domain :  (i,p)
         definition   :  sum(f,s(f,i,p)) ;

      VARIABLE:
         identifier   :  pStar
         index domain :  (i,p) | IsModelPeriod(p)
         definition   :  DEM_M(i,p) + DEM_S(i,p) * ( SUM(f, s(f,i,p)) + (a(i,p) $ arbitrage2(i)) )
         comment      :  "DEM_M(i,p) + DEM_S(i,p) * ( SUM(f, s(f,i,p)) + (a(i,p) $ arbitrage2(i)) )
                          EUR/MWh price of energy at node i" ;

      VARIABLE:
         identifier   :  wStar
         index domain :  (i,p) | IsModelPeriod(p)
         definition   :  SUM((k,ct), PTDF(i,k,ct,p)*(lambda_plus(k,ct,p)-lambda_min(k,ct,p)) )
         comment      :  "EUR/MWh price of transmission services from hub to i" ;

      VARIABLE:
         identifier   :  z
         index domain :  (m,p) | IsModelPeriod(p)
         definition   :  SUM[ (c,cc), PTCU(c,cc,m) * ( psa(c,cc,p) + SUM[ f | FirmInCountryCombo(f,c) , ps(f,c,cc,p) ] ) ]
         comment      :  "MW of flow through constrained interface m
                          (used in transportation model of transmission system)
                          
                          SUM((c,cc), PTCU(c,cc,m) * ( psa(c,cc,p) + SUM(f | FirmInCountryCombo(f,c), ps(f,c,cc,p)) ) )" ;

    ENDSECTION  ;

    DECLARATION SECTION Arbitrager_model

      COMPLEMENTARITY VARIABLE:
         identifier   :  thetaAS
         index domain :  (c,p)| (ArbitrageCountry(c) and IsModelPeriod(p))
         range        :  real
         complement   :  as(c,p) - SUM(cc, psa(cc,c,p) ) = 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  thetaAP
         index domain :  (c,p)| (ArbitrageCountry(c) and (IsModelPeriod(p)))
         range        :  real
         complement   :  -ap(c,p) + SUM(cc, psa(c,cc,p) ) = 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  gammAr
         index domain :  (am,p) | IsModelPeriod(p)
         range        :  nonnegative
         complement   :  SUM[(c,cc) | ArbitrageCountry(c) and ArbitrageCountry(cc), psa(c,cc,p)*ATCU(c,cc,am)] - TCA(am) <= 0 ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  psa
         index domain :  (c,cc,p) | (ArbitrageCountry(c)) and (ArbitrageCountry(cc)) and (IsModelPeriod(p))
         range        :  nonnegative
         complement   :  -1*(ETAX(c,cc) + SUM(m, wtStar(m,p) * PTCU(c,cc,m) )) + thetaAS(cc,p) - thetaAP(c,p)
                         - SUM[am, ATCU(c,cc,am)*gammAr(am,p)] <= 0
         comment      :  "MW power sales by the arbitragers in country cc
                          assigned to arbitrager purchases in country c" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  ap
         index domain :  (c,p)| (ArbitrageCountry(c)) and (IsModelPeriod(p))
         range        :  nonnegative
         complement   :  thetaAP(c,p) - rho(c,p) <= 0
         comment      :  "Net MW purchased by arbitragers in country c and transferred to other countries" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  as
         index domain :  (c,p)| (ArbitrageCountry(c)) and (IsModelPeriod(p))
         range        :  nonnegative
         complement   :  - thetaAS(c,p) + rho(c,p) <= 0
         comment      :  "Net MW sold by arbitragers in country c and transferred from other countries" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  a
         index domain :  (i,p)| (arbitrage2(i) and IsModelPeriod(p))
         range        :  real
         complement   :  (pStar(i,p)-wStar(i,p)) - SUM[c | BussesInCountryCombo(c,i), rho(c,p)] = 0
         comment      :  "MW transferred by arbitrager from hub node to node i
                          
                          (pStar(i,p)-wStar(i,p)) - SUM(c |(c,i) in CI, rho(c,p)) = 0" ;

      COMPLEMENTARITY VARIABLE:
         identifier   :  rho
         index domain :  (c,p)| (ArbitrageCountry(c)) and (IsModelPeriod(p))
         range        :  real
         complement   :  (ap(c,p) - as(c,p)) + SUM[ i | BussesInCountryCombo(c,i) and arbitrage2(i), a(i,p) ] = 0
         comment      :  "(ap(c,p) - as(c,p)) + SUM(i | (c,i) in CI and i in BussesA, a(i,p)) = 0
                          
                          (ap(c,p) - as(c,p)) + SUM[ l | l.t_country = c and (l.t_bus in BussesA), a(l.t_bus,p) ] = 0" ;

    ENDSECTION  ;

    DECLARATION SECTION 

      SET:
         identifier   :  SelectedEquations
         subset of    :  AllConstraints
         definition   :  data
                             { y          , wtStar     , lambda_plus, lambda_min , thetaS     , thetaG     , mu_min     , gamm       , mu_plus    ,
                               g          , s          , ps         , pStar      , wStar      , z          , thetaAS    , thetaAP    , gammAr     ,
                               psa        , ap         , as         , a          , rho        } ;

      SET:
         identifier   :  SelectedVariables
         subset of    :  AllVariables
         definition   :  data
                             { y          , wtStar     , lambda_plus, lambda_min , thetaS     , thetaG     , mu_min     , gamm       , mu_plus    ,
                               g          , s          , ps         , pStar      , wStar      , z          , thetaAS    , thetaAP    , gammAr     ,
                               psa        , ap         , as         , a          , rho        } ;

      PARAMETER:
         identifier   :  Choose
         index domain :  (mt)
         range        :  binary
         comment      :  "0 = run perfect competitive, 1 = run cournot model --> Calculation of the demand function changes by this." ;

      SET:
         identifier   :  ModelType
         index        :  mt
         definition   :  DATA{Competitive} ;

      MATHEMATICAL PROGRAM:
         identifier   :  COMPETES
         constraints  :  SelectedEquations
         variables    :  SelectedVariables
         type         :  mcp ;

    ENDSECTION  ;

  ENDSECTION KKT_Conditions ;

  SECTION Input_Data_management


    SECTION IO_procedures


      PROCEDURE
        identifier :  SeasonalHydro
        body       :  
          !GA_max(f,i,hu,'s',b) := GA_max(f,i,hu,'m',b);
          !GA_max(f,i,hu,'w',b) := GA_max(f,i,hu,'m',b);
          GA_max(f,'NOR',hu,'s',b) := 0.7 * GA_max(f,'NOR',hu,'m',b);
          GA_max(f,'NOR',hu,'w',b) := 1.3 * GA_max(f,'NOR',hu,'m',b);
          GA_max(f,'SWE',hu,'s',b) := 0.7 * GA_max(f,'SWE',hu,'m',b);
          GA_max(f,'SWE',hu,'w',b) := 1.3 * GA_max(f,'SWE',hu,'m',b);
          GA_max(f,'FIN',hu,'s',b) := 0.7 * GA_max(f,'FIN',hu,'m',b);
          GA_max(f,'FIN',hu,'w',b) := 1.3 * GA_max(f,'FIN',hu,'m',b);
          GA_max(f,'SWI',hu,'s',b) := 0.7 * GA_max(f,'SWI',hu,'m',b);
          GA_max(f,'SWI',hu,'w',b) := 1.3 * GA_max(f,'SWI',hu,'m',b);

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  PTDFtoSeason
        body       :  
          PTDF('NOR',k,ct,'s','super peak') := PTDF('DEW',k,ct,'s','super peak');
          PTDF('FIN',k,ct,'s','super peak') := PTDF('DEW',k,ct,'s','super peak');
          PTDF('SWE',k,ct,'s','super peak') := PTDF('DEW',k,ct,'s','super peak');

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  PTDFtoSeason2
        body       :  
          PTDF('NOR',k,ct,'s','off peak') := PTDF('DEW',k,ct,'s','off peak');
          PTDF('FIN',k,ct,'s','off peak') := PTDF('DEW',k,ct,'s','off peak');
          PTDF('SWE',k,ct,'s','off peak') := PTDF('DEW',k,ct,'s','off peak');

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  FullTrade
        body       :  
          FirmsTradeNode(f,i) := 1;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  RestrictTrade
        body       :  
          !EMPTY Flowgates, Countries, AllGens, Busses, SupFirms, Firms, PowerPlants, Shareholding, Interfaces, Scenario, Country, SupCountries;
          !CLEANDEPENDENTS Flowgates, Interfaces, Countries, SupCountries, AllGens, Busses, SupFirms, Firms, PowerPlants, Shareholding, Scenario, AllCases;
          
          FOR f | (sum(sh,StocksOfFirm(f,sh))=0) DO
            IF (sum(sh,StocksOfFirm(f,sh))=0)
            THEN FringeFirms(f) := 1;
            ENDIF
          ENDFOR;
          
          
          FOR (f,i,h,c) | ((g_unit(f,i,h)>0) AND BussesInCountryCombo(c,i)) DO
             IF ((g_unit(f,i,h)>0) and BussesInCountryCombo(c,i))
             THEN FirmsInCountry(f,c) := 1
             ENDIF
          ENDFOR;
          
          FOR (f,c,cc,i) | (FirmsInCountry(f,c) AND (TradeBetweenCountries(c,cc) = 1) AND BussesInCountryCombo(cc,i) AND (NOT FringeFirms(f))) DO
             IF (FirmsInCountry(f,c) AND (TradeBetweenCountries(c,cc) = 1) AND BussesInCountryCombo(cc,i) AND (NOT FringeFirms(f)))
             THEN FirmsTradeNode(f,i) := 1
             ENDIF
          ENDFOR;
          
          FOR (f,c,i) | (FirmsInCountry(f,c) AND BussesInCountryCombo(c,i)) DO
            IF (FirmsInCountry(f,c) AND BussesInCountryCombo(c,i))
            THEN FirmsTradeNode(f,i) := 1
            ENDIF
          ENDFOR;
          
          FOR (f,c,i) | (FirmsTradeNode(f,i) AND BussesInCountryCombo(c,i)) DO
            IF (FirmsTradeNode(f,i) AND BussesInCountryCombo(c,i))
            THEN FirmsTradeCountry(f,c) := 1
            ENDIF
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  InitialiseVar
        body       :  
          Hulp_WCT(m)             := 0;
          AdditionalCap(h)        := 0;
          AdditionalMC(h)         := 0;
          AuctionedInterface(m)   := 0;
          y(i,p)                  := 0;
          ConsumerSurplus(p)      := 0;
          pStar(i,p)              := 0;
          wtStar(m,p)             := 0;
          wStar(i,p)              := 0;
          a(i,p)                  := 0;
          Internal_source(h,p)    := 0;
          LeveringAanMarkt(h,b)   := 0;
          !CournotCase            := '1';

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Only_Reading_dbase
        body       :  
          EMPTY Flowgates, Countries, AllGens, Busses, SupFirms, Firms, PowerPlants, Shareholding, Interfaces, Scenario, Country, SupCountries;
          CLEANDEPENDENTS Flowgates, Interfaces, Countries, SupCountries, AllGens, Busses, SupFirms, Firms, PowerPlants, Shareholding, Scenario, AllCases;
          
          Read from table DBscenario              in merge mode;
          
          IF SUM(sc, ChooseScenario(sc)) = 0 THEN
            Scen := First(sc) ELSE
            Scen := First(sel)
          ENDIF;
          
          Read from table DBblock                         in replace mode;
          Read from table DBSeason                        in replace mode;
          Read from table DBbusses                        in replace mode;
          Read from table DBcountry                       in replace mode;
          Read from table DBflowgates                     in replace mode;
          Read from table DBfirms                         in replace mode;
          Read from table DBinterfaceCapacities           in replace mode;
          Read from table DBtech1                         in replace mode;
          Read from table DBtech2                         in replace mode;
          Read from table DBtech3                         in replace mode;
          Read from table DBtech4                         in replace mode;
          Read from table DBbuscountry                    in merge mode;
          Read from table DBcountry2country               in merge mode;
          Read from table DBcountry2countryInterface      in merge mode;
          Read from table DBdataOnFirmsAndNodes           in merge mode;
          Read from table DBdataOnNodeAndFlowg            in merge mode;
          Read from table DBinterfaceLink                 in merge mode;
          Read from table DBmodeltype                     in merge mode;
          Read from table DBEuropeanPowerPlants           in merge mode;
          Read from table DBOwnerships                    in merge mode;
          Read from table DBtechnConversion               in merge mode;
          Read from table DBtechnologies                  in merge mode;
          Read from table DBtechPerCountry                in merge mode;
          Read from table DBtimeLength                    in merge mode;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  AssignNewFuelTypes
        body       :  
          FOR (fu,ft,ofu,oft) DO
            IF FC(fu,ft,ofu,oft) THEN
                  FUV(ofu,oft) := fu;
                  FTV(ofu,oft) := ft;
            ENDIF
          ENDFOR;
          FOR pp DO
                  Fuel(pp)        := FUV(FuelOld(pp),FueltypeOld(pp));
                  Fueltype(pp)    := FTV(FuelOld(pp),FueltypeOld(pp));
          ENDFOR;
          
          OldPowerPlants                          :=      PowerPlants;
          OldCapacity(pp)                         :=      Capacity(pp);

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Ownership
        comment    :  "This procedure allocates units of shareholdings to the shareholders ,i.e. to the owners
                       of it, according to their stocks in the company.
                       Capacity of the original unit becomes zero if the plant is 100% owned by the main firm(s). The new unit Unit_tp_teller then
                       represents the original unit."
        body       :  
          ! If this procedure "Ownership" is run again it has to make sure that it uses only
          ! the powerplants that were originally in the database.
          
          GeneratingFirm(pp)      := OriginalGeneratingFirm(pp);
          
          SupPowerPlants          := OldPowerPlants * SupPowerPlants;
          PowerPlants             := OldPowerPlants * Powerplants;
          Capacity(pp)            := OldCapacity(pp);
          
          EMPTY DuplicatePlants, Owners, SharedPlants;
          Teller          := 1;
          
          ! For all shareholdings do
          FOR sh DO
                  Owners := {f $ StocksOfFirm(f,sh) > 0};
                  SharedPlants := {pp $ GeneratingFirm(pp) = sh};
          
                  ! For all combinations of owners and shared plants do
                  FOR (ow,tp) DO
                          NewName := FormatString("Unit_%e_%i", tp, Teller);
                          SetElementAdd(DuplicatePlants, NewUnit, NewName);
          
                          Country(NewUnit)                := Country(tp);
                          GeneratingFirm(NewUnit)         := ow;
                          Fuel(NewUnit)                   := Fuel(tp);
                          Fueltype(NewUnit)               := Fueltype(tp);
                          Bus(NewUnit)                    := Bus(tp);
                          OneBus(NewUnit)                 := OneBus(tp);
                          OperationStatus(NewUnit)        := OperationStatus(tp);
                          Capacity(NewUnit)               := Capacity(tp)*(StocksOfFirm(ow,sh)/100);
                          OnStream(NewUnit)               := OnStream(tp);
                          OffStream(NewUnit)              := OffStream(tp);
                          Altfuel(NewUnit)                := Altfuel(tp);
                          UnitType(NewUnit)               := UnitType(tp);
          
                          Teller  := Teller + 1;
                  ENDFOR;
                  Capacity(tp) := Capacity(tp) * MAX(0, (1- SUM[ow, (StocksOfFirm(ow,sh)/100)]));
          
          ENDFOR;
          PowerPlants += DuplicatePlants;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Aggregate_Units
        comment    :  "MB: Berekening efficiency moet gewogen efficiency worden!
                       MB: Maintanance costs should also be similar when clustered!"
        body       :  
          ! This procedure aggregates the powerplants which have been read in from the database. Otherwise you get too much units.
          ! The units of the same company, country, node, maintenance, fuel and efficiency are aggregated.
          
          EMPTY           P_hulp, CheckClusters, ClusterMatch(pp,ppp), InCluster(pp);
          EMPTY           AllGens, ThisUnit, Cluster;
          
          P_hulp                  :=      PowerPlants;
          Teller                  :=      1;
          
          ! If the generatingfirm does not belong to the mainset 'Firms' the firm is allocated to a fictive national company
          GeneratingFirm(pp) $ (NOT GeneratingFirm(pp) in Firms) :=       StringToElement(Firms, FormatString("Comp_%e", Country(pp)));
          
          FOR pp DO
                  ! This IF statements makes sure that plants, already clustered themselves are not checked once more:
                  IF InCluster(pp) = 0 THEN
                          Cluster         :=      {pp2 | Country(pp)=Country(pp2)
          !                                       AND (ABS(ThEfficiency(pp) - ThEfficiency(pp2)) <= BoundEff)
          !                                       AND Maintenance(pp)=Maintenance(pp2)
                                                  AND OperationStatus(pp)=OperationStatus(pp2)
                                                  AND GeneratingFirm(pp)=GeneratingFirm(pp2)
                                                  AND Fuel(pp)=Fuel(pp2)
                                                  AND Fueltype(pp) = Fueltype(pp2)
                                                  AND Bus(pp) = Bus(pp2) };
          
                          ClusterMatch(pp,ppp) $ (ppp in Cluster)         :=      1;
                          InCluster(ppp)  $ (Incluster(ppp) = 0)          :=      ClusterMatch(pp, ppp);
          
                          ! If a powerplant is already clustered, then there is no need to search on this powerplant for similar efficiencies
                          P_hulp          -=      Cluster;
                          CheckClusters   +=      Cluster;
          
                          IF (Card(Cluster) > 0) AND (OperationStatus(pp) = "OPR") AND (SUM[cp | cp in Cluster, Capacity(cp)] > 10) THEN
                                  NewName                 :=  FormatString("PowerUnits%i", Teller);
          
                                  ! Fill the set "AllGens" (this is the set with all units in the model) with the aggregated units
                                  SetElementAdd(AllGens, ThisUnit, NewName);
          
                                  ! Calculate specific parameters for the aggregated units in set "AllGens"
                                  CountryU(ThisUnit)              := Country(first(cp));
                                  GensCountryCombo(ThisUnit,CountryU(ThisUnit)) := 1;
                                  FirmU(ThisUnit)                 := GeneratingFirm(first(cp));
                                  FuelU(ThisUnit)                 := Fuel(first(cp));
                                  FueltypeU(ThisUnit)             := Fueltype(first(cp));
                                  BusU(ThisUnit)                  := Bus(first(cp));
          !                       TestBusU(ThisUnit)              := Onebus(first(cp));
                                  g_unit(FirmU(Thisunit),BusU(ThisUnit),Thisunit)
                                                                  := SUM[cp | cp in Cluster, Capacity(cp)];
                                  Operation(ThisUnit)             := OperationStatus(First(Cluster));
          
          !                       CapacityFactor(CountryU(ThisUnit),ThisUnit)     := CapFactor(first(cp));
          !                       Efficiency(ThisUnit)            := SUM[cp | cp in Cluster, ThEfficiency(cp) ] /Card(cp);
          !                       AvailSum(FirmU(Thisunit),BusU(ThisUnit),Thisunit)
          !                                                       := SUM[cp | cp in Cluster, AvSummer(cp)]/Card(cp);
          !                       AvailWint(FirmU(Thisunit),BusU(ThisUnit),Thisunit)
          !                                                       := SUM[cp | cp in Cluster, AvWinter(cp)]/Card(cp);
          !                       MaintenanceU(ThisUnit)          := Maintenance(first(cp));
          
                                  Teller                  := Teller + 1;
                          ENDIF;
                  ENDIF;
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  FillParameters
        body       :  
          Periods                                 :=      Seasons cross TimeBlocks;
          FOR sc DO
           Arbitrage(i)                           :=      Hulp_Arbitrage(sc);
           e(i)                                   :=      Hulp_e(sc);
           ETAX(c,cc)                             :=      Hulp_ETAX(sc);
           DEM_M_pc(i,p)                          :=      Hulp_DEM_M_pc(sc);
           WC(f,i)                                :=      Hulp_WC(sc);
           SFC(f,i)                               :=      Hulp_SFC(sc);
           Cournot(f,i)                           :=      Hulp_Cournot(sc);
          ENDFOR;
          CapacityFactor(c,h)                     :=      CapFactor(FuelU(h), FueltypeU(h),c);
          Qzero(i,p)                              :=      Hulp_Qzero(i,p);
          EE(i,p)                                 :=      Hulp_EE(i,p);
          Time(p)                                 :=      Hulp_Time(p);
          PTC(m,p)                                :=      Hulp_PTC(m);
          !WCT(f,m,p)                             :=      Hulp_WCT(m);
          PTDF(i,k,ct,p)                          :=      Hulp_PTDF(i,k,ct);
          TradeBetweenCountries(c,cc)             :=      Hulp_link(c,cc);
          For c DO
           availability(fu,ft,i,'w',b)$((c,i) in CI)      :=      AvWinter(fu,ft,c);
           availability(fu,ft,i,'s',b)$((c,i) in CI)      :=      AvSummer(fu,ft,c);
           availability(fu,ft,i,'m',b)$((c,i) in CI)      :=      (AvSummer(fu,ft,c) + AvWinter(fu,ft,c))/2;
          ENDFOR;
          
          ! To fill the dropdowns in the interface:
          FixPeriod       :=      First(Periods);
          FixFirms        :=      First(Firms);

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Copy_Hydro_and_Pumpstorage
        comment    :  "ook nog pumpunit"
        body       :  
          !PumpUnit := {h $ GensFueltypeCombo(h, 'PS') };
          
          GA_max(f,i,h,u,b)       := g_max(f,i,h,u,b);
          GA_min(f,i,h,u,b)       := 0;
          
          ! Do for all units belonging to hydro units (hu), but not in pumped storage:
          GPROD_max(f,i,hu,p)     := g_max(f,i,hu,p)*(CapacityFactor(CountryU(hu),hu)/0.5);
          
          GA_max(f,i,hu,u,b)      := 0;
          
          !GA_max(f,i,hu,u,b) $   [(GPROD_max(f,i,hu,u,b)-(GPROD_max(f,i,hu,u,b)/H_max(hu,u))*SUM[b2 | ord(b2) <= ord(b), Time(u,b2)]) > 0]
          !for super peak and peak period increase maximum capacity:
          GA_max(f,i,hu,u,b) $    [SUM[b2 | ord(b2) <= ord(b), Time(u,b2)]/H_max(hu,u) < 1]
                                  := GPROD_max(f,i,hu,u,b)-(GPROD_max(f,i,hu,u,b)/$H_max(hu,u))*(SUM[b2 | ord(b2) < ord(b), Time(u,b2)]
                                  + 0.5 * Time(b));
          
          !GA_max(f,i,hu,u,b) $   ([(GPROD_max(f,i,hu,u,b)-(GPROD_max(f,i,hu,u,b)/H_max(hu,u))*SUM[b2 | ord(b2) <= ord(b), Time(u,b2)]) < 0] AND
          !                        [(GPROD_max(f,i,hu,u,b)-(GPROD_max(f,i,hu,u,b)/H_max(hu,u))*SUM[b2 | ord(b2) <  ord(b), Time(u,b2)]) > 0])
          !for shoulder period reduce maximum capacity, while max cap stays zero for the off peak period:
          GA_max(f,i,hu,u,b) $    ([SUM[b2 | ord(b2) <= ord(b), Time(u,b2)]/H_max(hu,u) < 0] AND
                                   [SUM[b2 | ord(b2) <  ord(b), Time(u,b2)]/H_max(hu,u) > 0])
                                  := 0.5 * [GPROD_max(f,i,hu,u,b)-(GPROD_max(f,i,hu,u,b)/$H_max(hu,u))*(SUM[b2 | ord(b2) < ord(b), Time(u,b2)])]
                                  * (H_max(hu,u) - SUM[b2 | ord(b2) < ord(b), Time(u,b2)])/Time(b);
          
          
          ! Do for all units belonging to pumped storage units (pu)
          
          GPROD_max(f,i,pu,p)
                  := g_max(f,i,pu,p);
          
          GA_max(f,i,pu,u,b)
                  := 0;
          
          GA_max(f,i,pu,u,b) $
                  [(GPROD_max(f,i,pu,u,b)-(GPROD_max(f,i,pu,u,b)/H_max(pu,u))*SUM[b2 | ord(b2) <= ord(b), Time(u,b2)]) > 0]
                  := GPROD_max(f,i,pu,u,b)-(GPROD_max(f,i,pu,u,b)/$H_max(pu,u))*(SUM[b2 | ord(b2) < ord(b), Time(u,b2)]
                  + 0.5 * Time(b));
          
          GA_max(f,i,pu,u,b) $
                  ([(GPROD_max(f,i,pu,u,b)-(GPROD_max(f,i,pu,u,b)/H_max(pu,u))*SUM[b2 | ord(b2) <= ord(b), Time(u,b2)]) < 0] AND
                  [(GPROD_max(f,i,pu,u,b)-(GPROD_max(f,i,pu,u,b)/H_max(pu,u))*SUM[b2 | ord(b2) < ord(b), Time(u,b2)]) > 0])
                  := 0.5 * [GPROD_max(f,i,pu,u,b)-(GPROD_max(f,i,pu,u,b)/$H_max(pu,u))*(SUM[b2 | ord(b2) < ord(b), Time(u,b2)])]
                  * (H_max(pu,u) - SUM[b2 | ord(b2) < ord(b), Time(u,b2)])/Time(b);
          
          
          ! Calculate the pumping energy consumption
          
          GA_max(f,i,pu,u,b3) $
                  [  (DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) <= ord(b3), Time(u,b4)]) > 0]
                  := -DerPH * GPROD_max(f,i,pu,u,b3) + (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * ( SUM[b4 | ord(b4) < ord(b3), Time(u,b4)] + 0.5 * Time(u,b3) );
          
          
          GA_max(f,i,pu,u,b3) $
                  ([( DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) <= ord(b3), Time(u,b4)]) < 0] AND
                   [( DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) < ord(b3), Time(u,b4)]) > 0])
                  := - 0.5 * [ DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) < ord(b3), Time(u,b4)] ]
                  * (H_maxp(pu,u) - SUM[b4 | ord(b4) < ord(b3), Time(u,b4)])/Time(u,b3);
          
          GA_min(f,i,pu,u,b3) := GA_max(f,i,pu,u,b3);

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  AltHydroAllocation
        comment    :  "   IF ((Rico(hu,u) * Time1(u,b) + Cap0(hu,u)) > 0)
                          THEN
                           GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := (CapPrev + Cap0(hu,u) + Rico(hu,u) * Time1(u,b)) / 2;
                          ELSE
                           IF (CapPrev > 0)
                           THEN
                             GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := CapPrev * (Time0(hu,u) - TimePrev)/Time(u,b) / 2;
                           ENDIF
                          ENDIF;"
        body       :  
          !GA_max(f,i,h,p) := g_max(f,i,h,p);
          
          Time00(hu,u)    := sum(b,Time(u,b));
          Rico1(hu,u)     := -2 * Cap0(hu,u) * CFact(hu) / Time00(hu,u);
          
          FOR (hu,u) DO
            TimePrev      := 0;
            IF (CFact(hu) < 0.5)
            THEN
             CapPrev      := 2*CFact(hu)*Cap0(hu,u);
             FOR b DO
              GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := (CapPrev + 2*CFact(hu)*Cap0(hu,u) + Rico1(hu,u) * Time1(u,b)) / 2;
              TimePrev    := Time1(u,b);
              CapPrev     := Rico1(hu,u) * Time1(u,b) + 2*CFact(hu)*Cap0(hu,u);
             ENDFOR
            ELSE
             CapPrev      := Cap0(hu,u);
             FOR b DO
              GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := (CapPrev + Cap0(hu,u) + Rico2(hu,u) * Time1(u,b)) / 2;
              CapPrev     := Rico2(hu,u) * Time1(u,b) + Cap0(hu,u);
             ENDFOR
            ENDIF
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Hydro_and_Pumpstorage
        body       :  
          Cap0(h,u)       := sum((f,i),sum(b,g_max(f,i,h,u,b)))/sum(b,1);
          CFact(h)        := CapacityFactor(CountryU(h),h);
          Time0(h,u)      := CFact(h) * sum(b,Time(u,b)) * 2;
          Rico(h,u)       := -Cap0(h,u)/Time0(h,u);
          Rico2(hu,u)     := 2*Cap0(hu,u)/sum(b,Time(u,b))*(CFact(hu) - 1);
          
          Time00(hu,u)    := sum(b,Time(u,b));
          Rico1(hu,u)     := 2 * Cap0(hu,u) * CFact(hu) / Time00(hu,u);
          
          GA_max(f,i,h,u,b)       := g_max(f,i,h,u,b);
          GA_min(f,i,h,u,b)       := 0;
          GA_max(f,i,hu,u,b)      := 0;
          
          FOR (hu,u) DO
           CapPrev        := Cap0(hu,u);
           TimePrev       := 0;
           FOR b DO
            IF (CFact(hu) < 0.5)
            THEN
             IF ((Rico(hu,u) * Time1(u,b) + Cap0(hu,u)) > 0)
             THEN
              GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := (CapPrev + Cap0(hu,u) + Rico(hu,u) * Time1(u,b)) / 2;
             ELSE
              IF (CapPrev > 0)
              THEN
                GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := CapPrev * (Time0(hu,u) - TimePrev)/Time(u,b) / 2;
              ENDIF
             ENDIF;
             TimePrev     := Time1(u,b);
             CapPrev      := Rico(hu,u) * Time1(u,b) + Cap0(hu,u);
            ELSE
             GA_max(f,i,hu,u,b)$(g_unit(f,i,hu)>0) := (CapPrev + Cap0(hu,u) + Rico2(hu,u) * Time1(u,b)) / 2;
             CapPrev      := Rico2(hu,u) * Time1(u,b) + Cap0(hu,u);
            ENDIF
           ENDFOR
          ENDFOR;
          
          ! Do for all units belonging to pumped storage units (pu)
          GPROD_max(f,i,pu,p)
                  := g_max(f,i,pu,p);
          
          GA_max(f,i,pu,u,b)
                  := 0;
          
          ! Calculate the pumping energy consumption
          
          GA_max(f,i,pu,u,b3) $
                  [  (DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) <= ord(b3), Time(u,b4)]) > 0]
                  := -DerPH * GPROD_max(f,i,pu,u,b3) + (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * ( SUM[b4 | ord(b4) < ord(b3), Time(u,b4)] + 0.5 * Time(u,b3) );
          
          
          GA_max(f,i,pu,u,b3) $
                  ([( DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) <= ord(b3), Time(u,b4)]) < 0] AND
                   [( DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) < ord(b3), Time(u,b4)]) > 0])
                  := - 0.5 * [ DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) < ord(b3), Time(u,b4)] ]
                  * (H_maxp(pu,u) - SUM[b4 | ord(b4) < ord(b3), Time(u,b4)])/Time(u,b3);
          
          GA_min(f,i,pu,u,b3) := 1.1 * GA_max(f,i,pu,u,b3);
          
          FOR (pu,u) DO
           CapPrev        := Cap0(pu,u);
           TimePrev       := 0;
           FOR b DO
             IF ((Rico(pu,u) * Time1(u,b) + Cap0(pu,u)) > 0)
             THEN
              GA_max(f,i,pu,u,b)$(g_unit(f,i,pu)>0) := (CapPrev + Cap0(pu,u) + Rico(pu,u) * Time1(u,b)) / 2;
             ELSE
              IF (CapPrev > 0)
              THEN
                GA_max(f,i,pu,u,b)$(g_unit(f,i,pu)>0) := CapPrev * (Time0(pu,u) - TimePrev)/Time(u,b) / 2;
              ENDIF
             ENDIF;
             TimePrev     := Time1(u,b);
             CapPrev      := Rico(pu,u) * Time1(u,b) + Cap0(pu,u);
           ENDFOR
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Uniform_HU_diff_PS
        body       :  
          Cap0(h,u)       := sum((f,i),sum(b,g_max(f,i,h,u,b)))/sum(b,1);
          CFact(h)        := CapacityFactor(CountryU(h),h);
          Time0(h,u)      := CFact(h) * sum(b,Time(u,b)) * 2;
          Rico(h,u)       := -Cap0(h,u)/Time0(h,u);
          Rico2(hu,u)     := 2*Cap0(hu,u)/sum(b,Time(u,b))*(CFact(hu) - 1);
          
          Time00(hu,u)    := sum(b,Time(u,b));
          Rico1(hu,u)     := 2 * Cap0(hu,u) * CFact(hu) / Time00(hu,u);
          
          GA_max(f,i,h,u,b)       := g_max(f,i,h,u,b);
          GA_min(f,i,h,u,b)       := 0;
          GA_max(f,i,hu,u,b)      := 0;
          
          GA_max(f,i,hu,u,b)      := CFact(hu) * g_max(f,i,hu,u,b);
          
          ! Do for all units belonging to pumped storage units (pu)
          GPROD_max(f,i,pu,p)
                  := g_max(f,i,pu,p);
          
          GA_max(f,i,pu,u,b)
                  := 0;
          
          ! Calculate the pumping energy consumption
          
          GA_max(f,i,pu,u,b3) $
                  [  (DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) <= ord(b3), Time(u,b4)]) > 0]
                  := -DerPH * GPROD_max(f,i,pu,u,b3) + (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * ( SUM[b4 | ord(b4) < ord(b3), Time(u,b4)] + 0.5 * Time(u,b3) );
          
          
          GA_max(f,i,pu,u,b3) $
                  ([( DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) <= ord(b3), Time(u,b4)]) < 0] AND
                   [( DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) < ord(b3), Time(u,b4)]) > 0])
                  := - 0.5 * [ DerPH * GPROD_max(f,i,pu,u,b3) - (DerPH * GPROD_max(f,i,pu,u,b3)/H_maxp(pu,u)) * SUM[b4 | ord(b4) < ord(b3), Time(u,b4)] ]
                  * (H_maxp(pu,u) - SUM[b4 | ord(b4) < ord(b3), Time(u,b4)])/Time(u,b3);
          
          GA_min(f,i,pu,u,b3) := GA_max(f,i,pu,u,b3);
          
          FOR (pu,u) DO
           CapPrev        := Cap0(pu,u);
           TimePrev       := 0;
           FOR b DO
             IF ((Rico(pu,u) * Time1(u,b) + Cap0(pu,u)) > 0)
             THEN
              GA_max(f,i,pu,u,b)$(g_unit(f,i,pu)>0) := (CapPrev + Cap0(pu,u) + Rico(pu,u) * Time1(u,b)) / 2;
             ELSE
              IF (CapPrev > 0)
              THEN
                GA_max(f,i,pu,u,b)$(g_unit(f,i,pu)>0) := CapPrev * (Time0(pu,u) - TimePrev)/Time(u,b) / 2;
              ENDIF
             ENDIF;
             TimePrev     := Time1(u,b);
             CapPrev      := Rico(pu,u) * Time1(u,b) + Cap0(pu,u);
           ENDFOR
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  ReadInputDatabase
        comment    :  "Read from table DBbuscountry            in replace mode;
                       Read from table DBgenerators in replace mode;
                       Read from table DBmargcosts in replace mode;
                       Read from table DBdataonFirmsAndNodes in replace mode;
                       Read from table DBspecificationGens in replace mode;
                       Read from table DBdataOnNodeAndFlowg in replace mode;"
        body       :  
          Run Only_Reading_dbase;
          Run AssignNewFuelTypes;
          Run Ownership;
          Run Aggregate_Units;
          Run FillParameters;
          !Run Hydro_and_Pumpstorage;
          Run Uniform_HU_diff_PS;
          
          UPDATE MC;
          
          Run RestrictTrade;
          Run PTDFtoSeason;
          Run SeasonalHydro;

      ENDPROCEDURE  ;

    ENDSECTION IO_procedures ;

    DECLARATION SECTION Input_Parameters

      PARAMETER:
         identifier   :  FringeFirms
         index domain :  (f) ;

      PARAMETER:
         identifier   :  FirmsInCountry
         index domain :  (f,c) ;

      PARAMETER:
         identifier   :  FirmsTradeNode
         index domain :  (f,i) ;

      PARAMETER:
         identifier   :  FirmsTradeCountry
         index domain :  (f,c) ;

      PARAMETER:
         identifier   :  TradeBetweenCountries
         index domain :  (c,cc) ;

      PARAMETER:
         identifier   :  StocksOfFirm
         index domain :  (f,sh)
         range        :  nonnegative
         comment      :  "Firm 'f' owns StocksOfFirm of Firm 'sh'" ;

      PARAMETER:
         identifier   :  Arbitrage
         index domain :  (i)
         range        :  binary
         comment      :  "If node/buss i is subjected to arbitrage than 1 else 0." ;

      PARAMETER:
         identifier   :  Arbitrage2
         index domain :  (i)
         definition   :  IF (Arbitrage(i)> 0 AND SUM(p, Qzero(i,p)) > 0) THEN
                         1
                         ELSE
                         0
                         ENDIF 
         comment      :  "The nodes at which no demand is allocated should not be included in the set of nodes where
                          arbitrage is possible, this would end up in an unfeasible solution.
                          Therefore we included the additional requirement that Qzero should be positive." ;

      PARAMETER:
         identifier   :  ArbitrageCountry
         index domain :  (c)
         definition   :  IF SUM[i | BussesInCountryCombo(c,i) = 1 , Arbitrage2(i)] > 0 THEN
                         1
                         ELSE
                         0
                         ENDIF  ;

      PARAMETER:
         identifier   :  BussesInCountryCombo
         index domain :  (c,i)
         comment      :  "Control parameter for dbase communication." ;

      SET:
         identifier   :  Scenario
         indices      :  sc, scc
         order by     :  -sc ;

      STRING PARAMETER:
         identifier   :  ODBCDatabase
         definition   :  "Link E20model.dsn" ;

      STRING PARAMETER:
         identifier   :  NameTableFirmsandNodes
         index domain :  sc ;

      STRING PARAMETER:
         identifier   :  NameTableFirms
         index domain :  sc ;

      STRING PARAMETER:
         identifier   :  NameTableInterfaces
         index domain :  sc ;

      STRING PARAMETER:
         identifier   :  NameTableOwnerships
         index domain :  sc ;

      PARAMETER:
         identifier   :  ChooseScenario
         index domain :  sc ;

      SET:
         identifier   :  SelectedScenario
         subset of    :  Scenario
         index        :  sel
         definition   :  {sc | ChooseScenario(sc) = 1} ;

      ELEMENT PARAMETER:
         identifier   :  Scen
         range        :  Scenario
         default      :  'Structure2005' ;

    ENDSECTION  ;

    DECLARATION SECTION Database_Declarations

      DATABASE TABLE:
         identifier  :  DBEuropeanPowerPlants
         data source :  ODBCDatabase
         table name  :  "aaEuropean Power Plants"
         mapping     :  "UNIT"       --> pp,
                        "GENERATOR"  --> OriginalGeneratingFirm(pp),
                        "COUNTRY1"   --> Country(pp),
                        "MW"         --> Capacity(pp),
                        "STATUS"     --> OperationStatus(pp),
                        "ON-STREAM"  --> OnStream(pp),
                        "UTYPE"      --> UnitType(pp),
                        "FUEL"       --> FuelOld(pp),
                        "FUELTYPE"   --> FueltypeOld(pp),
                        "ALTFUEL"    --> Altfuel(pp),
                        "OFF-STREAM" --> OffStream(pp),
                        "BUS"        --> Bus(pp),
                        "ONEBUS"     --> Onebus(pp)
         comment     :  "!\"Choose\"               -->     ChooseScenario(sc)" ;

      DATABASE TABLE:
         identifier  :  DBblock
         data source :  ODBCDatabase
         table name  :  "Block"
         mapping     :  "BlockInput" --> b,
                        "BlockOrder" --> OrdBlocks(b) ;

      DATABASE TABLE:
         identifier  :  DBbuscountry
         data source :  ODBCDatabase
         table name  :  "Buscountry"
         mapping     :  "Bus"          --> i,
                        "Country"      --> c,
                        "BusInCountry" --> BussesInCountryCombo(c,i),
                        "BusOrder"     --> OrdBus(i) ;

      DATABASE TABLE:
         identifier  :  DBbusses
         data source :  ODBCDatabase
         table name  :  "Busses"
         mapping     :  "Bus"           --> i,
                        "Season"        --> u,
                        "Block"         --> b,
                        "InitialDemand" --> Hulp_Qzero(i,u,b),
                        "Exports"       --> Hulp_EE(i,u,b)
         comment     :  "\"DemandSlope\" --> DEM_S(i,p)," ;

      DATABASE TABLE:
         identifier  :  DBcountry
         data source :  ODBCDatabase
         table name  :  "Country"
         mapping     :  "Country"      --> c,
                        "CountryOrder" --> OrdCountries,
                        "CountryName"  --> NameCountry ;

      DATABASE TABLE:
         identifier  :  DBcountry2country
         data source :  ODBCDatabase
         table name  :  "Country2Country"
         mapping     :  "Scenario"           --> sc,
                        "ExportTaxArbitrage" --> Hulp_ETAX(sc),
                        "DemandIntercept"    --> Hulp_Dem_M_pc(sc),
                        "ArbitrageBusses"    --> Hulp_Arbitrage(sc),
                        "Elasticity"         --> Hulp_e(sc) ;

      DATABASE TABLE:
         identifier  :  DBcountry2countryInterface
         data source :  ODBCDatabase
         table name  :  "Country2CountryInterface"
         mapping     :  "CountryTo"     --> cc,
                        "CountryFrom"   --> c,
                        "Interface"     --> m,
                        "TransferChang" --> PTCU(c,cc,m) ;

      DATABASE TABLE:
         identifier  :  DBdataOnFirmsAndNodes
         data source :  ODBCDatabase
         table name  :  NameTableFirmsandNodes(Scen)
         mapping     :  "Scenario"      --> sc,
                        "ResponseSlope" --> Hulp_WC(sc),
                        "SupplySlope"   --> Hulp_SFC(sc),
                        "Cournot"       --> Hulp_Cournot(sc)  ;

      DATABASE TABLE:
         identifier  :  DBdataOnNodeAndFlowg
         data source :  ODBCDatabase
         table name  :  "DataOnNodeandFlowg"
         mapping     :  "Bus"           --> i,
                        "Flowgate"      --> k,
                        "Contingencies" --> ct,
                        "PTDfactor"     --> Hulp_PTDF(i,k,ct) ;

      DATABASE TABLE:
         identifier  :  DBfirms
         data source :  ODBCDatabase
         table name  :  NameTableFirms(Scen)
         mapping     :  "Firm" --> f,
                        "FirmOrder" --> OrdFirms(f)  ;

      DATABASE TABLE:
         identifier  :  DBflowgates
         data source :  ODBCDatabase
         table name  :  "Flowgates"
         mapping     :  "Flowgate"      --> k,
                        "Contingencies" --> ct,
                        "Upper"         --> T(k,ct),
                        "FlowgateOrder" --> OrdFlowgate(k) ;

      DATABASE TABLE:
         identifier  :  DBinterfaceCapacities
         data source :  ODBCDatabase
         table name  :  "InterfaceCapacities"
         mapping     :  "Interfaces"   --> m,
                        "Transfer"     --> Hulp_PTC(m),
                        "InterfaceOrd" --> OrdInterfaces ;

      DATABASE TABLE:
         identifier  :  DBinterfaceLink
         data source :  ODBCDatabase
         table name  :  "InterfaceLink"
         mapping     :  "CountryA"     --> c,
                        "CountryB"     --> cc,
                        "LinkA"        --> Hulp_link(c,cc) ;

      DATABASE TABLE:
         identifier  :  DBmodeltype
         data source :  ODBCDatabase
         table name  :  "ModelType"
         mapping     :  "Item"          --> ModelType,
                        "Value"         --> Choose  ;

      DATABASE TABLE:
         identifier  :  DBOwnerships
         data source :  ODBCDatabase
         table name  :  NameTableOwnerships(Scen)
         mapping     :  "COMPANY"      --> f,
                        "SHAREHOLDING" --> sh,
                        "STOCKS"       --> StocksOfFirm(f,sh)  ;

      DATABASE TABLE:
         identifier  :  DBscenario
         data source :  ODBCDatabase
         table name  :  "Scenarios"
         mapping     :  "Scenario"           --> sc,
                        "TableFirmsandNodes" --> NameTableFirmsandNodes(sc),
                        "TableFirms"         --> NameTableFirms(sc),
                        "TableInterfaces"    --> NameTableInterfaces(sc),
                        "TableOwnerships"    --> NameTableOwnerships(sc)
         comment     :  "!\"Choose\"               -->     ChooseScenario(sc)" ;

      DATABASE TABLE:
         identifier  :  DBSeason
         data source :  ODBCDatabase
         table name  :  "Season"
         mapping     :  "SeasonInput" --> u,
                        "SeasonOrder" --> OrdSeason(u) ;

      DATABASE TABLE:
         identifier  :  DBtech1
         data source :  ODBCDatabase
         table name  :  "Tech1"
         mapping     :  "FUEL1" --> ofu ;

      DATABASE TABLE:
         identifier  :  DBtech2
         data source :  ODBCDatabase
         table name  :  "Tech2"
         mapping     :  "FUELTYPE1" --> oft ;

      DATABASE TABLE:
         identifier  :  DBtech3
         data source :  ODBCDatabase
         table name  :  "Tech3"
         mapping     :  "FUELNEW"   --> fu,
                        "FUELORDER" --> OrdFuels(fu) ;

      DATABASE TABLE:
         identifier  :  DBtech4
         data source :  ODBCDatabase
         table name  :  "Tech4"
         mapping     :  "FUELTYPENEW"   --> ft,
                        "FUELTYPEORDER" --> OrdFuelTypes(ft) ;

      DATABASE TABLE:
         identifier  :  DBtechnConversion
         data source :  ODBCDatabase
         table name  :  "TechnConversion"
         mapping     :  "FUEL"          --> ofu,
                        "FUELTYPE"      --> oft,
                        "FUELNEW"       --> fu,
                        "FUELTYPENEW"   --> ft,
                        "FuelCombi"     --> FC(fu,ft,ofu,oft) ;

      DATABASE TABLE:
         identifier  :  DBtechnologies
         data source :  ODBCDatabase
         table name  :  "Technologies"
         mapping     :  "FUELNEW"     --> fu,
                        "FUELTYPENEW" --> ft,
                        "EMISSIONS"   --> FuelEmission(fu,ft),
                        "VAR O&M"     --> Maintenance(fu,ft) ;

      DATABASE TABLE:
         identifier  :  DBtechPerCountry
         data source :  ODBCDatabase
         table name  :  "TechPerCountry"
         mapping     :  "FUELNEW"     --> fu,
                        "FUELTYPENEW" --> ft,
                        "COUNTRY"     --> c,
                        "PRICE1"      --> Fuelprice(fu,ft,c),
                        "EFFICIENCY1" --> Efficiency(fu,ft,c),
                        "WINTERAV"    --> AvWinter(fu,ft,c),
                        "SUMMERAV"    --> AvSummer(fu,ft,c),
                        "CFACTOR"     --> CapFactor(fu,ft,c) ;

      DATABASE TABLE:
         identifier  :  DBtimeLength
         data source :  ODBCDatabase
         table name  :  "TmeLength"
         mapping     :  "SeasonInput" --> u,
                        "BlockInput"  --> b,
                        "TimeLength"  --> Hulp_Time(u,b) ;

    ENDSECTION  ;

    DECLARATION SECTION Parameters_on_NonAggregated_Plants

      PARAMETER:
         identifier   :  ClusterMatch
         index domain :  (pp,ppp) ;

      SET:
         identifier   :  PowerPlants
         subset of    :  SupPowerPlants
         indices      :  pp, ppp ;

      SET:
         identifier   :  SupPowerPlants
         index        :  spp ;

      ELEMENT PARAMETER:
         identifier   :  Country
         index domain :  (pp)
         range        :  SupCountries
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  GeneratingFirm
         index domain :  (pp)
         range        :  SupFirms
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  OriginalGeneratingFirm
         index domain :  (pp)
         range        :  SupFirms
         default      :  '' ;

      PARAMETER:
         identifier   :  Capacity
         index domain :  (pp) ;

      PARAMETER:
         identifier   :  Capacity1
         index domain :  (pp) ;

      STRING PARAMETER:
         identifier   :  OperationStatus
         index domain :  (pp) ;

      PARAMETER:
         identifier   :  OnStream
         index domain :  (pp) ;

      STRING PARAMETER:
         identifier   :  UnitType
         index domain :  (pp) ;

      ELEMENT PARAMETER:
         identifier   :  Fuel
         index domain :  (pp)
         range        :  SupFuels
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  Fueltype
         index domain :  (pp)
         range        :  SupFuelTypes
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  FuelOld
         index domain :  (pp)
         range        :  OldSupFuels
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  FueltypeOld
         index domain :  (pp)
         range        :  OldFuelTypes
         default      :  '' ;

      STRING PARAMETER:
         identifier   :  Altfuel
         index domain :  (pp) ;

      PARAMETER:
         identifier   :  OffStream
         index domain :  (pp) ;

      ELEMENT PARAMETER:
         identifier   :  Bus
         index domain :  (pp)
         range        :  SupBusses
         default      :  '' ;

      ELEMENT PARAMETER:
         identifier   :  Onebus
         index domain :  (pp)
         range        :  SupBusses
         default      :  '' ;

      PARAMETER:
         identifier   :  AvSummer
         index domain :  (fu,ft,c) ;

      PARAMETER:
         identifier   :  AvWinter
         index domain :  (fu,ft,c) ;

      SET:
         identifier   :  P_hulp
         subset of    :  PowerPlants
         index        :  pp2 ;

      PARAMETER:
         identifier   :  Teller ;

      SET:
         identifier   :  Cluster
         subset of    :  PowerPlants
         index        :  cp ;

      SET:
         identifier   :  CheckClusters
         subset of    :  PowerPlants ;

      PARAMETER:
         identifier   :  BoundEff
         definition   :  0.1 ;

      ELEMENT PARAMETER:
         identifier   :  ThisUnit
         range        :  AllGens
         default      :  '' ;

      STRING PARAMETER:
         identifier   :  NewName ;

      PARAMETER:
         identifier   :  InCluster
         index domain :  (pp) ;

      PARAMETER:
         identifier   :  Maintenance
         index domain :  (fu,ft) ;

      PARAMETER:
         identifier   :  CapFactor
         index domain :  (fu,ft,c) ;

    ENDSECTION  ;

    DECLARATION SECTION Processing_Ownerships

      SET:
         identifier   :  Owners
         subset of    :  Firms
         index        :  ow ;

      SET:
         identifier   :  SharedPlants
         subset of    :  SupPowerPlants
         index        :  tp ;

      SET:
         identifier   :  DuplicatePlants
         subset of    :  PowerPlants
         index        :  dp ;

      PARAMETER:
         identifier   :  OldCapacity
         index domain :  pp ;

      ELEMENT PARAMETER:
         identifier   :  NewUnit
         range        :  SupPowerPlants
         default      :  '' ;

      SET:
         identifier   :  OldPowerPlants
         subset of    :  SupPowerPlants ;

    ENDSECTION  ;

    DECLARATION SECTION Processing_hydro

      PARAMETER:
         identifier   :  temp
         index domain :  (u,b)
         definition   :  SUM[b2 | ord(b2) < ord(b), Time(u,b2)] ;

      PARAMETER:
         identifier   :  CFact
         index domain :  (h) ;

      PARAMETER:
         identifier   :  Cap0
         index domain :  (h,u) ;

      PARAMETER:
         identifier   :  CapPrev ;

      PARAMETER:
         identifier   :  Time0
         index domain :  (h,u) ;

      PARAMETER:
         identifier   :  Time00
         index domain :  (h,u) ;

      PARAMETER:
         identifier   :  Time1
         index domain :  (u,b)
         definition   :  SUM[b2 | ord(b2) <= ord(b), Time(u,b2)] ;

      PARAMETER:
         identifier   :  Time2
         index domain :  (u,b)
         definition   :  SUM[b2 | ord(b2) < ord(b), Time(u,b2)] ;

      PARAMETER:
         identifier   :  TimePrev ;

      PARAMETER:
         identifier   :  Rico
         index domain :  (h,u) ;

      PARAMETER:
         identifier   :  Rico1
         index domain :  (h,u) ;

      PARAMETER:
         identifier   :  Rico2
         index domain :  (h,u) ;

    ENDSECTION  ;

  ENDSECTION Input_Data_management ;

  SECTION Output_Data_management


    SECTION OI_procedures


      PROCEDURE
        identifier :  Fill_Set_Cases
        comment    :  "This procedure fills the set Cases with the Filenames of the Cases"
        body       :  
          empty HulpCases;
          
          FOR acs DO
          SetElementAdd(HulpCases,NewCase,CaseFilename(acs));
          SetElementAdd(Cases,NewCase,CaseFilename(acs));
          Cases := Cases * Hulpcases;
          
          ENDFOR;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Calculate_Welfares
        comment    :  "Procedure wordt aangeroepen op pagina Demand Curve and Transmission Capacity"
        body       :  
          Run Fill_Set_Cases;
          
          SelectedBaseCase                :=      First(acs $ FormatString("%e", BaseCase) = CaseFileName(acs));
          Pzero(i,p)                      :=      SelectedBaseCase.pStar(i,p);
          DEM_S_Dummy(i,p)                :=      (1/e(i))*Pzero(i,p)/$Qzero(i,p);
          DEM_M_Dummy(i,p)                :=      Pzero(i,p) - DEM_S_Dummy(i,p)*(Qzero(i,p) + EE(i,p)+AD(i,p)-Load_Decrease(i,p));
          ConsumerSurplusPC(p)            :=      SUM[i, [DEM_M_Dummy(i,p) - Pzero(i,p)]/2 * Qzero(i,p)];
          ConsumerSurplus(p)              :=      SUM[i, [DEM_M_Dummy(i,p) - PStar(i,p)]/2 * NodalSales(i,p)];
          NodalCS_PC(i,p)                 :=      [DEM_M_Dummy(i,p) - Pzero(i,p)]/2 * NodalSales(i,p);
          NodalCS(i,p)                    :=      [DEM_M_Dummy(i,p) - PStar(i,p)]/2 * NodalSales(i,p);
          
          
          Welfare(p)                              :=      ConsumerSurplus(p) + TotalProfit(p) + TotalCostsForTransportation(p);
          GenCostsPC(p)                           :=      SelectedBaseCase.GenCosts(p);
          TotalProfitPC(p)                        :=      SelectedBaseCase.TotalProfit(p);
          TotalCostsForTransportationPC(p)        :=      SelectedBaseCase.TotalCostsForTransportation(p);
          ConsumerSurplusPC(p)                    :=      SelectedBaseCase.ConsumerSurplus(p);
          WelfarePC(p)                            :=      ConsumerSurplusPC(p) + TotalProfitPC(p) + TotalCostsForTransportationPC(p);
          
          DeltaGenCosts(p)                        :=      GenCosts(p) - GenCostsPC(p);
          DeltaConsumerSurplus(p)                 :=      ConsumerSurplus(p) - ConsumerSurplusPC(p);
          WelfareLoss(p)                          :=      Welfare(p) - WelfarePC(p);

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  LernerIndex
        comment    :  "+SUM(cc, SUM(m, wtStar(m,p) * PTCU(cc,'Netherlands',m))))"
        body       :  
          Maroeska (f,c,p):= thetaS(f,c,p);
          !Maroeska (f,c,p):= SUM(cc,(thetaS(f,c,p) + SUM(m, wtStar(m,p) * PTCU(cc,c,m))));
          
          
          LernerIndexS(f,'Netherlands',p)$s(f,'DIEM',p) := (Pstar('DIEM',p)-(Maroeska(f,'Netherlands',p)))/Pstar('DIEM',p);
          LernerIndexS(f,'Belgium',p)$s(f,'GRAM',p) := (Pstar('GRAM',p)-(Maroeska(f,'Belgium',p)))/Pstar('GRAM',p);
          LernerIndexS(f,'Germany',p)$s(f,'D',p) := (Pstar('D',p)-(Maroeska(f,'Germany',p)))/Pstar('D',p);
          LernerIndexS(f,'France',p)$s(f,'F',p) := (Pstar('F',p)-(Maroeska(f,'France',p)))/Pstar('F',p);

      ENDPROCEDURE  ;

    ENDSECTION OI_procedures ;

    DECLARATION SECTION Output_depending_on_Cases

      ELEMENT PARAMETER:
         identifier   :  NewCase
         range        :  Cases
         comment      :  "mag weg? Fieke" ;

      SET:
         identifier   :  Cases
         index        :  css ;

      SET:
         identifier   :  HulpCases
         subset of    :  Cases ;

      INDEX:
         identifier   :  acs
         range        :  AllCases ;

      ELEMENT PARAMETER:
         identifier   :  SelectedBaseCase
         range        :  AllCases
         definition   :  !Element(AllCases, Ord(BaseCase,Cases))
                         ;

      ELEMENT PARAMETER:
         identifier   :  BaseCase
         range        :  Cases ;

      ELEMENT PARAMETER:
         identifier   :  Copy_BaseCase
         range        :  Cases ;

      ELEMENT PARAMETER:
         identifier   :  SelectedPartialCase
         range        :  AllCases
         definition   :  First(acs $ FormatString("%e", PartialCase) = CaseFileName(acs))
                         !Element(AllCases, Ord(PartialCase, Cases))
                         ;

      ELEMENT PARAMETER:
         identifier   :  PartialCase
         range        :  Cases ;

      ELEMENT PARAMETER:
         identifier   :  Copy_PartialCase
         range        :  Cases ;

      STRING PARAMETER:
         identifier   :  CaseAcronym
         index domain :  acs
         definition   :  DataFileGetAcronym(acs, CaseAcronym(acs)) ;

      STRING PARAMETER:
         identifier   :  CaseFilename
         index domain :  (acs)
         definition   :  DataFileGetName(acs,CaseFilename(acs))  ;

      ELEMENT PARAMETER:
         identifier   :  CournotCase
         range        :  Cases ;

      ELEMENT PARAMETER:
         identifier   :  Copy_CournotCase
         range        :  Cases ;

      ELEMENT PARAMETER:
         identifier   :  SelectedCournotCase
         range        :  AllCases
         definition   :  First(acs $ FormatString("%e", CournotCase) = CaseFileName(acs))
                         !Element(AllCases, Ord(CournotCase,Cases))
                         ;

      PARAMETER:
         identifier   :  LoadCournot ;

    ENDSECTION  ;

    DECLARATION SECTION Average_Outputs_Prices_and_Sales

      PARAMETER:
         identifier   :  AvgPStar
         index domain :  (i)
         definition   :  SUM[p, pStar(i,p)*Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgNodalSales
         index domain :  (i)
         definition   :  SUM[p, NodalSales(i,p)*Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgWstar
         index domain :  (i)
         definition   :  SUM[p, wStar(i,p)*Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgY
         index domain :  i
         definition   :  SUM[p, y(i,p)*Time(p)]/SUM[p, Time(p)]
         comment      :  "Weighted MW. Average MW of transmission services provided by TSO from hub node to node \"i\"" ;

      PARAMETER:
         identifier   :  AvgZ
         index domain :  m
         definition   :  SUM[p, z(m,p)*Time(p)]/SUM[p, Time(p)]
         comment      :  "Average MW of flow through constrained interface m during the year
                          (used in transportation model of transmission system)" ;

      PARAMETER:
         identifier   :  AvgWtStar
         index domain :  (m)
         definition   :  SUM[p, wtStar(m,p)*Time(p)]/SUM[p, Time(p)]
         comment      :  "Weighted Average MW price of transfer capacbility for interface m. This is the price
                          associated with use of transfer capabilities represented as a transportation model." ;

      PARAMETER:
         identifier   :  AvgCompanySales
         index domain :  (f)
         definition   :  SUM[p,Time(p)*SUM(i, s(f,i,p))]/SUM[p, Time(p)]
         comment      :  "Weighted Average MW" ;

      PARAMETER:
         identifier   :  AvgCompanyProfits
         index domain :  (f)
         definition   :  SUM[p, CompanyProfit(f,p)*Time(p)]/SUM[p, Time(p)]
         comment      :  "Weighted average €/hr" ;

      PARAMETER:
         identifier   :  AvgNationalPrice
         index domain :  c
         definition   :  SUM[p, NationalPrice(c,p)*Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgNationalSales
         index domain :  c
         definition   :  SUM[p, NationalSales(c,p)*Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgNationalY
         index domain :  c
         definition   :  SUM[p, NationalY(c,p)*Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgSalesAmongCountries
         index domain :  (c,cc)
         definition   :  SUM[p, TotalSalesAmongCountries(c,cc,p) * Time(p)]/SUM[p, Time(p)]
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  AvgArbitrageAmongCountries
         index domain :  (c,cc)
         definition   :  SUM[p, psa(c,cc,p) * Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgCompanySalesAmongCountries
         index domain :  (f,c,cc)
         definition   :  SUM[p, ps(f,c,cc,p) * Time(p)]/SUM[p, Time(p)]
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  AvgCompanyImport
         index domain :  (f,c)
         definition   :  SUM[p, CompanyImport(f,c,p) * Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgLernerIndex
         index domain :  (f,c)
         definition   :  SUM[(p), LernerIndexS(f,c,p) * Time(p)]/SUM[p, Time(p)] ;

      PARAMETER:
         identifier   :  AvgLernerIndexPerCountry
         index domain :  (c,p)
         definition   :  sum(f,LernerIndexS(f,c,p)*TotalSalesInCountry(f,c,p))/$ NationalSales(c,p) ;

    ENDSECTION  ;

    DECLARATION SECTION Yearly_Outputs

      SET:
         identifier   :  DummySet
         index        :  ds
         definition   :  Data{1} ;

      PARAMETER:
         identifier   :  YearlyWelfarePC
         index domain :  (ds)
         definition   :  SelectedBaseCase.YearlyWelfare(ds) ;

      PARAMETER:
         identifier   :  YearlyWelfare
         index domain :  (ds)
         definition   :  YearlyConsumerSurplus(ds) + YearlyTotalProfit(ds) + YearlyCostsforTransportation(ds) ;

      PARAMETER:
         identifier   :  YearlyWelfareLoss
         index domain :  (ds)
         definition   :  SUM[p, WelfareLoss(p)*Time(p)]/1000000
         comment      :  "[mln EUR]" ;

      PARAMETER:
         identifier   :  YearlyDeltaGenCosts
         index domain :  (ds)
         definition   :  SUM[p, DeltaGenCosts(p)*Time(p)]/1000000
         comment      :  "[mln EUR]" ;

      PARAMETER:
         identifier   :  YearlyProductionEffLoss
         index domain :  (ds)
         definition   :  SUM[p, ProductionEfficiencyLoss(p)*Time(p)]/1000000
         comment      :  "[mln EUR]" ;

      PARAMETER:
         identifier   :  YearlyDeltaConsumerSurplus
         index domain :  (ds)
         definition   :  SUM[p, DeltaConsumerSurplus(p)*Time(p)]/1000000
         comment      :  "[mln EUR]" ;

      PARAMETER:
         identifier   :  YearlyAllocatedEffLoss
         index domain :  (ds)
         definition   :  SUM[p, AllocatedEfficiencyLoss(p)*Time(p)]/1000000
         comment      :  "[mln EUR]" ;

      PARAMETER:
         identifier   :  YearlyCostsPC
         index domain :  (ds)
         definition   :  SelectedBaseCase.YearlyGenCosts(ds) ;

      PARAMETER:
         identifier   :  YearlyGenCosts
         index domain :  (ds)
         definition   :  SUM[p, GenCosts(p) * Time(p)]/1000000 ;

      PARAMETER:
         identifier   :  YearlyConsumerSurplus
         index domain :  (ds)
         definition   :  SUM[p, ConsumerSurplus(p) * Time(p)]/1000000
         comment      :  "mln EU" ;

      PARAMETER:
         identifier   :  YearlyConsumerSurplusPC
         index domain :  (ds)
         definition   :  SelectedBaseCase.YearlyConsumerSurplus(ds) ;

      PARAMETER:
         identifier   :  YearlyTotalProfit
         index domain :  (ds)
         definition   :  SUM[p, TotalProfit(p)*Time(p)]/1000000
         comment      :  "mln EUR" ;

      PARAMETER:
         identifier   :  YearlyWheelingCosts
         index domain :  (ds)
         definition   :  SUM[p, WheelingCosts(p)*Time(p)]/1000000
         comment      :  "mln EUR" ;

      PARAMETER:
         identifier   :  YearlyCostsforTransportation
         index domain :  (ds)
         definition   :  SUM[p, TotalCostsForTransportation(p)*Time(p)]/1000000
         comment      :  "mln EUR" ;

      PARAMETER:
         identifier   :  YearlyCompanySales
         index domain :  (f)
         definition   :  SUM[p,Time(p)*SUM(i, s(f,i,p))]
         comment      :  "MWh" ;

      PARAMETER:
         identifier   :  YearlyCompanyProfits
         index domain :  (f)
         definition   :  SUM[p, CompanyProfit(f,p)*Time(p)]/1000000
         comment      :  "mln €" ;

      PARAMETER:
         identifier   :  YearlyCostsForTaxes
         index domain :  ds
         definition   :  SUM[p, TotalCostsForTaxes(p) * Time(p)]/1000000
         comment      :  "mln EUR" ;

    ENDSECTION  ;

    DECLARATION SECTION Output_info_on_Welfare

      PARAMETER:
         identifier   :  AllocatedEfficiencyLoss
         index domain :  (p)
         definition   :  WelfareLoss(p) - ProductionEfficiencyLoss(p)
         comment      :  "[EUR/hr]
                          This represents the welfare loss by decreased allocation efficiency of the demand.
                          For cournot this should be compared with the cases that are partial competitive." ;

      PARAMETER:
         identifier   :  ProductionEfficiencyLoss
         index domain :  (p)
         definition   :  TotalCostsForGeneration(p) - SelectedPartialCase.TotalCostsForGeneration(p)
         comment      :  "[EUR/hr]" ;

      PARAMETER:
         identifier   :  DeltaGenCosts
         index domain :  (p)
         comment      :  "[EUR/hr]" ;

      PARAMETER:
         identifier   :  DeltaConsumerSurplus
         index domain :  (p)
         comment      :  "[EUR/hr], calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  WelfareLoss
         index domain :  (p)
         comment      :  "[EUR/hr] Difference in welfare current cases minus welfare of case = cs,
                          calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  ConsumerSurplusPC
         index domain :  (p)
         comment      :  "Calculated in Procedure Calculate_Welfares
                          SUM[i, [DEM_M_Dummy(i,p) + Pzero(i,p)]/2 * [Qzero(i,p) + EE(i,p)] ]" ;

      PARAMETER:
         identifier   :  ConsumerSurplus
         index domain :  (p)
         comment      :  ", calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  GenCostsPC
         index domain :  (p)
         comment      :  "EUR/hr, calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  GenCosts
         index domain :  (p)
         definition   :  SUM[f, TotalGenCosts(f,p)]
         comment      :  "EUR/hr" ;

      PARAMETER:
         identifier   :  WelfarePC
         index domain :  (p)
         comment      :  "EUR/hr, calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  Welfare
         index domain :  (p)
         comment      :  "EUR/hr, calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  NodalCS
         index domain :  (i,p)
         comment      :  "Calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  NodalCS_PC
         index domain :  (i,p)
         comment      :  "Calculated in Procedure Calculate_Welfares" ;

      PARAMETER:
         identifier   :  CheckQzero
         index domain :  (i,p)
         definition   :  NodalSales(i,p)-Qzero(i,p) ;

      PARAMETER:
         identifier   :  CheckPzero
         index domain :  (i,p)
         definition   :  Pstar(i,p)-Pzero(i,p) ;

      PARAMETER:
         identifier   :  CheckNodalCS
         index domain :  (i,p)
         definition   :  NodalCS(i,p)-NodalCS_PC(i,p) ;

    ENDSECTION  ;

    DECLARATION SECTION Output_Info_on_Plants

      PARAMETER:
         identifier   :  CompanyFuelmix
         index domain :  (f,fu,p)
         definition   :  SUM((i,h) | GensFuelCombo(h,fu), g_max(f,i,h,p))
         comment      :  "!SUM((i,h) | FuelU(h) = fu, g_max(f,i,h,p))" ;

      PARAMETER:
         identifier   :  CompanyGenerationFuelmix
         index domain :  (f,fu,p)
         definition   :  SUM((i,h) | GensFuelCombo(h,fu), g(f,i,h,p))
         comment      :  "!SUM((i,h) | FuelU(h) = fu, g(f,i,h,p))" ;

      PARAMETER:
         identifier   :  CountryFuelmix
         index domain :  (c,fu,p)
         definition   :  SUM[ (f,i,h) | (GensCountryCombo(h,c) AND GensFuelCombo(h,fu)),  g_max(f,i,h,p) ]
         comment      :  "!SUM[ (f,i,h) | (CountryU(h) = c AND FuelU(h) = fu),  g_max(f,i,h,p) ]" ;

      PARAMETER:
         identifier   :  CountryGenerationFuelmix
         index domain :  (c,fu,p)
         definition   :  SUM[ (f,i,h) |  (GensCountryCombo(h,c) AND GensFuelCombo(h,fu)),  g(f,i,h,p) ]
         comment      :  "!SUM[ (f,i,h) | (CountryU(h) = c AND FuelU(h) = fu),  g(f,i,h,p) ]" ;

      PARAMETER:
         identifier   :  CapacityAtNode
         index domain :  (i,p)
         definition   :  SUM[(f,h), g_max(f,i,h,p)] ;

      PARAMETER:
         identifier   :  LoadAtNode
         index domain :  (i,p)
         definition   :  Qzero(i,p) + EE(i,p) + AD(i,p) - Load_Decrease(i,p) ;

    ENDSECTION  ;

    DECLARATION SECTION Output_Info_on_Companies

      PARAMETER:
         identifier   :  CompanyProfit
         index domain :  (f,p)
         definition   :  CompanyRevenue(f,p) - CompanyCostsForGeneration(f,p) - CompanyCostsForTransportation(f,p)
                         - CompanyCostsForTransmission(f,p) - CompanyCostsForTaxes(f,p)
         comment      :  "€ per hour" ;

      PARAMETER:
         identifier   :  CompanyProfitInternalSource
         index domain :  (f,p)
         definition   :  CompanyRevenueInternalSource(f,p) - CompanyCostsForGenerationInternalSource(f,p)
                         
                         ! - CompanyCostsForTransportation(f,p) - CompanyCostsForTransmission(f,p) - CompanyCostsForTaxes(f,p)
         comment      :  "€ per hour" ;

      PARAMETER:
         identifier   :  CompanyCapacity
         index domain :  (f,p)
         definition   :  SUM[(i,h),GA_max(f,i,h,p)] ;

      PARAMETER:
         identifier   :  TotalProfit
         index domain :  (p)
         definition   :  SUM(f, CompanyProfit(f,p))  ;

      PARAMETER:
         identifier   :  TotalProfitPC
         index domain :  (p) ;

      PARAMETER:
         identifier   :  CompanyRevenue
         index domain :  (f,p)
         definition   :  SUM(i, pStar(i,p) * s(f,i,p)) ;

      PARAMETER:
         identifier   :  CompanyRevenueInternalSource
         index domain :  (f,p)
         definition   :  SUM[(i,h), GA_max(f,i,h,p) * Internal_source(h,p) * pStar(i,p)]
         comment      :  "EUR/hr
                          MB Eigenlijk niet helemaal goed, want marktprijs bij productie node wordt gebruikt.
                          We weten echter niet waar de interne doorleveringen worden verkocht." ;

      PARAMETER:
         identifier   :  TotalRevenue
         index domain :  p
         definition   :  SUM[ f, CompanyRevenue(f,p) ] ;

      PARAMETER:
         identifier   :  WheelingCosts
         index domain :  p
         definition   :  SUM( i, wStar(i,p) * y(i,p) )
         comment      :  "EUR/hour TotalCostsForTransmission" ;

      PARAMETER:
         identifier   :  TransferCosts
         index domain :  p
         definition   :  SUM[m, wtStar(m,p)*z(m,p)]
         comment      :  "Total transmision costs on flowgates" ;

      PARAMETER:
         identifier   :  CompanyCostsAll
         index domain :  (f,p)
         definition   :  CompanyCostsForTransportation(f,p) + CompanyCostsForTransmission(f,p) + CompanyCostsForGeneration(f,p)
                         + CompanyCostsForTaxes(f,p) ;

      PARAMETER:
         identifier   :  TotalCostsAll
         index domain :  p
         definition   :  SUM[ f, CompanyCostsAll(f,p) ] ;

      PARAMETER:
         identifier   :  CompanyCostsForTransportation
         index domain :  (f,p)
         definition   :  SUM[(c,cc), SUM[m, wtStar(m,p) * PTCU(c,cc,m) ] * ps(f,c,cc,p)]
         comment      :  "Transmission costs of firm f over all nodes (buses)" ;

      PARAMETER:
         identifier   :  TotalCostsForTransportation
         index domain :  p
         definition   :  SUM(f, CompanyCostsForTransportation(f,p))
         comment      :  "EUR/hr" ;

      PARAMETER:
         identifier   :  TotalCostsForTransportationPC
         index domain :  (p) ;

      PARAMETER:
         identifier   :  CompanyCostsForGeneration
         index domain :  (f,p)
         definition   :  SUM( (i, h)$ UnitInGensCombo(h,f,i), (MC(h)) * g(f,i,h,p) )
         comment      :  "EUR/hr" ;

      PARAMETER:
         identifier   :  CompanyCostsForGenerationInternalSource
         index domain :  (f,p)
         definition   :  SUM[(i,h), GA_max(f,i,h,p) * Internal_source(h,p) * MC(h)]
         comment      :  "EUR/hr" ;

      PARAMETER:
         identifier   :  YearlyCompCostsGen
         index domain :  (f)
         definition   :  SUM[p, Time(p)*CompanyCostsForGeneration(f,p)]
         comment      :  "EUR" ;

      PARAMETER:
         identifier   :  TotalCostsForGeneration
         index domain :  p
         definition   :  SUM((f), CompanyCostsForGeneration(f,p))
         comment      :  "EUR/hr" ;

      PARAMETER:
         identifier   :  CompanyCostsForTaxes
         index domain :  (f,p)
         definition   :  SUM[ (c,cc), ETAX(c,cc) * ps(f,c,cc,p) ] ;

      PARAMETER:
         identifier   :  TotalCostsForTaxes
         index domain :  p
         definition   :  SUM(f, CompanyCostsForTaxes(f,p)) ;

      PARAMETER:
         identifier   :  CompanyCostsForTransmission
         index domain :  (f,p)
         definition   :  SUM[ i, wStar(i,p) * (s(f,i,p) - SUM[h, g(f,i,h,p)])]
         comment      :  "Transmission costs of firm f over all nodes (buses)" ;

      PARAMETER:
         identifier   :  TotalCostsForTransmission
         index domain :  p
         definition   :  SUM(f, CompanyCostsForTransmission(f,p)) ;

      PARAMETER:
         identifier   :  CompanyGeneration
         index domain :  (f,p)
         definition   :  SUM((i,h) $ UnitInGensCombo(h,f,i), g(f,i,h,p))
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  YearlyCompGen
         index domain :  f
         definition   :  SUM[p, CompanyGeneration(f,p)*Time(p)]
         comment      :  "MWh" ;

      PARAMETER:
         identifier   :  NodalSales
         index domain :  (i,p)
         definition   :  SUM(f, s(f,i,p)) + (a(i,p) $ arbitrage2(i))
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  CompanySales
         index domain :  (f,p)
         definition   :  SUM(i, s(f,i,p))
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  CompanyImport
         index domain :  (f,cc,p)
         definition   :  sum(c,ps(f,c,cc,p)) -
                         sum(i | BussesInCountryCombo(cc,i), sum(h | UnitInGensCombo(h,f,i), g(f,i,h,p))) ;

      FILE:
         identifier   :  OutputFile
         device       :  disk
         mode         :  replace ;

    ENDSECTION  ;

    DECLARATION SECTION Periodical_Outputs

      PARAMETER:
         identifier   :  TestPTDF
         index domain :  (k,ct,p)
         definition   :  SUM((i), y(i,p)*PTDF(i,k,ct,p))
         comment      :  "Fieke" ;

      PARAMETER:
         identifier   :  NationalPrice
         index domain :  (c,p)
         definition   :  SUM[ i | BussesInCountryCombo(c,i), pStar(i,p) * NodalSales(i,p)]/$SUM[ i | BussesInCountryCombo(c,i), NodalSales(i,p)]
         comment      :  "Nodal price weighted by the nodal sales" ;

      PARAMETER:
         identifier   :  NationalSales
         index domain :  (c,p)
         definition   :  SUM[ i | BussesInCountryCombo(c,i), NodalSales(i,p)]
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  NationalGeneration
         index domain :  (c,p)
         definition   :  SUM[i $ BussesInCountryCombo(c,i), TotalGenerationAtNode(i,p)]
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  NationalY
         index domain :  (c,p)
         definition   :  SUM[ i | BussesInCountryCombo(c,i), y(i,p)]
         comment      :  "National transmission services" ;

      PARAMETER:
         identifier   :  NationalImport
         index domain :  (c,p)
         definition   :  NationalSales(c,p) - NationalGeneration(c,p)
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  TotalCostsInclTax
         index domain :  (f,p)
         definition   :  TotalTransCosts(f,p) + TotalGenCosts(f,p) + SUM((c,cc), ETAX(c,cc) * ps(f,c,cc,p))
         comment      :  "Transmission plus Generation plus Tax costs" ;

      PARAMETER:
         identifier   :  TotalGenCosts
         index domain :  (f,p)
         definition   :  CompanyCostsForGeneration(f,p) ;

      PARAMETER:
         identifier   :  SumTotalGenCosts
         index domain :  p
         definition   :  TotalCostsForGeneration(p) ;

      PARAMETER:
         identifier   :  SumTotalCosts
         index domain :  p
         definition   :  SUM(f, TotalCostsInclTax(f,p)) ;

      PARAMETER:
         identifier   :  Profit
         index domain :  (f,p)
         definition   :  Revenue(f,p) - TotalGenCosts(f,p) - TotalTransCosts(f,p)
         comment      :  "EUR per hour" ;

      PARAMETER:
         identifier   :  TotalSales
         index domain :  (f,p)
         definition   :  SUM(i, s(f,i,p))
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  TotalSalesInCountry
         index domain :  (f,c,p)
         definition   :  SUM[ i | BussesInCountryCombo(c,i), s(f,i,p)]
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  MarketShare
         index domain :  (f,c,p)
         definition   :  100*(TotalSalesInCountry(f,c,p)/$SUM[i $ BussesInCountryCombo(c,i), NodalSales(i,p)])
         comment      :  "%" ;

      PARAMETER:
         identifier   :  TotalSalesperNode
         index domain :  (i,p)
         definition   :  SUM(f, s(f,i,p)) + (a(i,p) $ arbitrage2(i)) ;

      PARAMETER:
         identifier   :  Revenue
         index domain :  (f,p)
         definition   :  SUM(i, pStar(i,p) * s(f,i,p)) ;

      PARAMETER:
         identifier   :  TotalTransCosts
         index domain :  (f,p)
         definition   :  SUM(i, wStar(i,p) * (s(f,i,p) - SUM(h | UnitInGensCombo(h,f,i), g(f,i,h,p))))
                         + SUM((c,cc), SUM(m, wtStar(m,p) * PTCU(c,cc,m) ) * ps(f,c,cc,p) )
         comment      :  "Transmission costs of firm f over all nodes (buses)" ;

      PARAMETER:
         identifier   :  TotalGen
         index domain :  (f,p)
         definition   :  SUM((i,h) $ UnitInGensCombo(h,f,i), g(f,i,h,p)) ;

      PARAMETER:
         identifier   :  TotalGenerationAtNode
         index domain :  (i,p)
         definition   :  SUM[(f,h), g(f,i,h,p)] ;

      PARAMETER:
         identifier   :  TotalSalesAmongCountries
         index domain :  (c,cc,p)
         definition   :  SUM[f, ps(f,c,cc,p)]
         comment      :  "MW power sales from country c to cc by all companies" ;

      PARAMETER:
         identifier   :  LernerIndexS
         index domain :  (f,c,p) ;

      PARAMETER:
         identifier   :  Maroeska
         index domain :  (f,c,p)|TotalSalesInCountry(f,c,p) ;

    ENDSECTION  ;

    DECLARATION SECTION Output_info_on_Emissions

      PARAMETER:
         identifier   :  PeriodicalCompanyEmissions
         index domain :  (f,p)
         definition   :  SUM( (i,h,c) $FirmInCountryCombo(f,c), (CO2_Emissions(h,c)) * g(f,i,h,p) * Time(p) )/1000000000
         comment      :  "Mton : [kg/MWh] * [MW] * [hour] = kg" ;

      PARAMETER:
         identifier   :  YearlyCompanyEmissions
         index domain :  (f)
         definition   :  SUM( (i,h,p,c) $ FirmInCountryCombo(f,c), (CO2_Emissions(h,c)) * g(f,i,h,p) * Time(p) )/1000000000
         comment      :  "Mton: [kg/MWh] * [MW] * [hour] = kg" ;

      PARAMETER:
         identifier   :  PeriodicalEmissions
         index domain :  (p)
         definition   :  SUM[f, PeriodicalCompanyEmissions(f,p)]
         comment      :  "Mton" ;

      PARAMETER:
         identifier   :  YearlyEmissions
         index domain :  ds
         definition   :  SUM[p, PeriodicalEmissions(p)]
         comment      :  "Mton" ;

      PARAMETER:
         identifier   :  YearlyEmissionsPC
         index domain :  ds
         definition   :  SelectedBaseCase.YearlyEmissions(ds)
         comment      :  "Mton" ;

      PARAMETER:
         identifier   :  YearlyEmissionLoss
         index domain :  (ds)
         definition   :  YearlyEmissions(ds)-YearlyEmissionsPC(ds) ;

      PARAMETER:
         identifier   :  YearlyProductionEmissionLoss
         index domain :  (ds)
         definition   :  YearlyEmissions(ds) - SelectedPartialCase.YearlyEmissions(ds) ;

      PARAMETER:
         identifier   :  YearlyAllocatedEmissionLoss
         index domain :  (ds)
         definition   :  YearlyEmissionLoss(ds) - YearlyProductionEmissionLoss(ds) ;

      PARAMETER:
         identifier   :  PeriodicalCountryEmissions
         index domain :  (c,p)
         definition   :  SUM[(f,i,h) | BussesInCountryCombo(c,i), (CO2_Emissions(h,c)) * g(f,i,h,p) * Time(p)]/1000000000
         comment      :  "Mton: [kg/MWh] * [MW] * [hour] = kg" ;

      PARAMETER:
         identifier   :  YearlyCountryEmissions
         index domain :  (c)
         definition   :  SUM[ p , PeriodicalCountryEmissions(c,p) ]
         comment      :  "Mton" ;

    ENDSECTION  ;

    DECLARATION SECTION Outputs_for_NMA

      PARAMETER:
         identifier   :  Productie
         index domain :  (f,p)
         definition   :  CompanyGeneration(f,p) + Company_InternalSource(f,p)
         comment      :  "MW" ;

      PARAMETER:
         identifier   :  Verkoop
         index domain :  (f,p)
         definition   :  TotalSalesInCountry(f,'NL',p) + Company_InternalSource(f,p) ;

      PARAMETER:
         identifier   :  JaarVerkoop
         index domain :  (f)
         definition   :  SUM[p, (Verkoop(f,p) * Time(p))/1000]
         comment      :  "GWh" ;

      PARAMETER:
         identifier   :  JaarImport
         index domain :  (c)
         definition   :  SUM(p, NationalImport(c,p)*Time(p))/1000 ;

      PARAMETER:
         identifier   :  JaarDoorlevering
         index domain :  (f)
         definition   :  SUM(p, Company_InternalSource(f,p)*Time(p))/1000
         comment      :  "GWh" ;

      PARAMETER:
         identifier   :  JaarOpbrengsten
         index domain :  f
         definition   :  SUM[p, PeriodCompanyProfits(f,p)]
         comment      :  "mln €" ;

      PARAMETER:
         identifier   :  JaarOpbrengstenInternalSource
         index domain :  f
         definition   :  SUM[p, PeriodCompanyProfitInternalSource(f,p)]
         comment      :  "mln €" ;

      PARAMETER:
         identifier   :  PeriodCompanyProfits
         index domain :  (f,p)
         definition   :  CompanyProfit(f,p)*Time(p)/1000000
         comment      :  "mln €" ;

      PARAMETER:
         identifier   :  PeriodCompanyProfitInternalSource
         index domain :  (f,p)
         definition   :  CompanyProfitInternalSource(f,p)*Time(p)/1000000
         comment      :  "mln €" ;

    ENDSECTION  ;

  ENDSECTION Output_Data_management ;

  SECTION Interface_Data_management


    SECTION Button_procedures


      PROCEDURE
        identifier :  Set_Qzero_to_initial
        body       :  
          Run Fill_Set_Cases;
          Run Alternative_to_Qzero;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  Alternative_to_Qzero
        body       :  
          IF ChangeInitialDemand = 1 THEN
          Qzero(i,p) := MAX(0, SelectedCournotCase.NodalSales(i,p) - EE(i,p))
          ELSE
          Qzero(i,p) := Hulp_Qzero(i,p)
          ENDIF;

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  OpenDatabase
        body       :  
          OpenDocument("E20model.mdb");

      ENDPROCEDURE  ;

      PROCEDURE
        identifier :  OpenDocumentation
        body       :  
          OpenDocument("Documentation\\Model description.doc");

      ENDPROCEDURE  ;

    ENDSECTION Button_procedures ;

    DECLARATION SECTION Interface_Declarations

      STRING PARAMETER:
         identifier   :  Country_names
         index domain :  c
         definition   :  FormatString("%e", c) ;

      STRING PARAMETER:
         identifier   :  Country_Node
         index domain :  (i)
         definition   :  SUM(c $ BussesInCountryCombo(c,i), Country_names(c)) ;

      STRING PARAMETER:
         identifier   :  Node_names
         index domain :  i
         definition   :  FormatString("%s_%e",Country_Node(i),i) ;

      ELEMENT PARAMETER:
         identifier   :  FixPeriod
         range        :  Periods ;

      ELEMENT PARAMETER:
         identifier   :  FixFirms
         range        :  Firms ;

      PARAMETER:
         identifier   :  Hulp_PTC
         index domain :  m ;

      PARAMETER:
         identifier   :  Hulp_link
         index domain :  (c,cc) ;

      PARAMETER:
         identifier   :  Hulp_WC
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_SFC
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_Cournot
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_ETAX
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_WCT
         index domain :  (m) ;

      PARAMETER:
         identifier   :  Hulp_Dem_M_pc
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_Qzero
         index domain :  (i,u,b) ;

      PARAMETER:
         identifier   :  Hulp_EE
         index domain :  (i,u,b) ;

      PARAMETER:
         identifier   :  Hulp_Time
         index domain :  (u,b) ;

      PARAMETER:
         identifier   :  Hulp_Arbitrage
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_e
         index domain :  sc ;

      PARAMETER:
         identifier   :  Hulp_PTDF
         index domain :  (i,k,ct) ;

    ENDSECTION  ;

  ENDSECTION Interface_Data_management ;

  PROCEDURE
    identifier :  MainInitialization
    body       :  
      Qzero(i,p) := Hulp_Qzero(i,p);
      IsModelPeriod(p) := 1;
      
      Run Fill_Set_Cases;
      
      IF Ord(BaseCase,Cases) = 0 THEN
      BaseCase := First(Cases)
      ENDIF;
      
      IF Ord(PartialCase,Cases) = 0 THEN
      PartialCase := First(Cases)
      ENDIF;

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainExecution
    comment    :  "Periods for which the model must run can be selected via input pages. The model solves for each consecutive period selected."
    body       :  
      Run Fill_Set_Cases;
      
      ShowProgressWindow(1);
      
      FOR p $ SelectedPeriods(p)  DO
          empty IsModelPeriod;
          IsModelPeriod(p) := 1;
          solve COMPETES in merge mode;
          break when COMPETES.ProgramStatus = 'Infeasible';
          PageRefreshAll;
      ENDFOR;
      IsModelPeriod(p) := 1;
      
      Run Calculate_Welfares;
      
      /*
      PUT OutputFile;
      OutputFile.PageMode := 'on';
      PUTHD /,/,/,
      "Testing Conjectured Supply Function Models",/,
      "-------------------------------------------";
      PUTFT /,/, "PageNumber  ", OutputFile.PageNumber;
      
      PUT //;
      DISPLAY
              CI:2,
              a(i,p):2, g(f,i,h,p):2:2:1, s(f,i,p):2,
              pStar(i,p):2, wStar(i,p):2, y(i,p):2,
              PTDF(i,k,ct,p):2, MC(h):3, g_max(f,i,h,p):2:2:1, Cournot(f,i):2,
              lambda_plus(k,ct,p):2, lambda_min(k,ct,p):2;
      
      
      PUTCLOSE;
      
      DISPLAY a(i,p);
      */

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainTermination
    body       :  
      if ( CaseSaveAll( confirm:2 ) = 1 ) then
          return 1;
      else
          return 0;
      endif ;

  ENDPROCEDURE  ;

ENDMODEL Main_Competes21 ;
